# Generated from C:/Users/natar/AI/AS400Parser/grammars/db2_parser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,228,991,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,1,0,5,0,200,8,0,10,0,12,0,203,9,0,1,0,1,0,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,223,8,1,1,
        2,1,2,1,3,1,3,3,3,229,8,3,1,3,1,3,1,3,1,3,1,3,3,3,236,8,3,1,3,1,
        3,1,3,3,3,241,8,3,1,3,1,3,3,3,245,8,3,1,3,1,3,1,3,3,3,250,8,3,1,
        3,1,3,3,3,254,8,3,1,3,1,3,3,3,258,8,3,1,3,1,3,3,3,262,8,3,1,4,1,
        4,1,4,5,4,267,8,4,10,4,12,4,270,9,4,1,4,3,4,273,8,4,1,5,1,5,3,5,
        277,8,5,1,5,3,5,280,8,5,1,5,1,5,1,5,1,5,3,5,286,8,5,1,6,1,6,1,7,
        1,7,1,7,1,7,1,7,1,7,3,7,296,8,7,1,7,1,7,5,7,300,8,7,10,7,12,7,303,
        9,7,1,8,1,8,3,8,307,8,8,1,8,3,8,310,8,8,1,8,1,8,1,8,1,8,3,8,316,
        8,8,1,8,3,8,319,8,8,1,8,1,8,1,8,3,8,324,8,8,1,8,1,8,3,8,328,8,8,
        1,8,3,8,331,8,8,3,8,333,8,8,1,9,1,9,1,10,1,10,1,11,1,11,1,12,1,12,
        1,13,1,13,1,13,3,13,346,8,13,1,13,1,13,3,13,350,8,13,1,13,1,13,1,
        13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,361,8,13,1,14,1,14,1,15,1,
        15,1,15,5,15,368,8,15,10,15,12,15,371,9,15,1,16,1,16,1,17,1,17,1,
        17,5,17,378,8,17,10,17,12,17,381,9,17,1,18,1,18,1,19,1,19,1,19,5,
        19,388,8,19,10,19,12,19,391,9,19,1,20,1,20,3,20,395,8,20,1,21,1,
        21,1,22,1,22,1,23,1,23,1,23,1,23,3,23,405,8,23,1,23,3,23,408,8,23,
        1,24,1,24,1,24,1,24,1,24,1,24,1,24,3,24,417,8,24,1,24,1,24,1,24,
        3,24,422,8,24,1,25,1,25,1,25,1,25,5,25,428,8,25,10,25,12,25,431,
        9,25,1,25,1,25,1,26,1,26,1,26,5,26,438,8,26,10,26,12,26,441,9,26,
        1,27,1,27,1,27,1,27,1,27,1,27,5,27,449,8,27,10,27,12,27,452,9,27,
        1,27,1,27,3,27,456,8,27,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,
        1,29,3,29,467,8,29,1,30,1,30,1,30,1,30,3,30,473,8,30,1,30,3,30,476,
        8,30,1,30,1,30,1,30,3,30,481,8,30,1,30,3,30,484,8,30,1,30,1,30,1,
        30,1,30,1,30,1,30,3,30,492,8,30,1,30,1,30,1,30,1,30,1,30,3,30,499,
        8,30,1,31,1,31,1,32,1,32,1,32,1,32,1,32,5,32,508,8,32,10,32,12,32,
        511,9,32,1,33,1,33,1,33,1,33,1,33,3,33,518,8,33,1,33,1,33,1,33,1,
        34,1,34,1,34,1,34,3,34,527,8,34,1,35,1,35,1,35,1,35,1,35,1,35,1,
        35,5,35,536,8,35,10,35,12,35,539,9,35,1,35,1,35,1,36,1,36,1,36,5,
        36,546,8,36,10,36,12,36,549,9,36,1,37,1,37,1,37,1,37,1,37,1,37,1,
        37,1,37,3,37,559,8,37,1,37,1,37,3,37,563,8,37,1,37,1,37,1,37,1,37,
        1,37,1,37,1,37,1,37,3,37,573,8,37,1,37,1,37,1,37,1,37,1,37,3,37,
        580,8,37,1,37,1,37,1,37,3,37,585,8,37,1,38,1,38,1,39,1,39,1,40,1,
        40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
        41,1,41,1,41,1,41,1,41,3,41,610,8,41,3,41,612,8,41,1,42,1,42,1,43,
        1,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,625,8,44,1,44,1,44,
        1,44,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,46,
        1,46,1,46,1,46,3,46,645,8,46,1,46,1,46,1,46,3,46,650,8,46,1,46,1,
        46,3,46,654,8,46,1,46,1,46,3,46,658,8,46,1,47,1,47,1,48,1,48,1,49,
        1,49,1,50,1,50,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,52,
        690,8,52,1,53,1,53,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,
        1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,
        3,54,716,8,54,1,54,1,54,1,54,1,54,1,54,3,54,723,8,54,1,55,1,55,1,
        55,1,55,1,56,1,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,58,1,
        58,1,58,5,58,742,8,58,10,58,12,58,745,9,58,1,59,1,59,1,60,1,60,1,
        61,1,61,1,61,5,61,754,8,61,10,61,12,61,757,9,61,1,62,1,62,1,63,1,
        63,1,63,1,63,1,63,1,63,1,63,1,63,1,64,1,64,3,64,771,8,64,1,65,1,
        65,3,65,775,8,65,1,65,1,65,1,65,3,65,780,8,65,1,66,1,66,3,66,784,
        8,66,1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,69,1,69,1,70,1,70,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,3,72,813,8,72,1,72,1,72,1,72,1,72,5,72,819,8,72,10,72,
        12,72,822,9,72,1,73,1,73,1,73,1,73,3,73,828,8,73,1,74,1,74,1,75,
        1,75,1,75,3,75,835,8,75,1,75,1,75,1,76,1,76,1,77,1,77,1,78,1,78,
        1,79,1,79,1,79,3,79,848,8,79,1,80,1,80,1,81,1,81,1,82,1,82,1,83,
        1,83,1,83,3,83,859,8,83,1,83,1,83,3,83,863,8,83,1,83,1,83,1,83,3,
        83,868,8,83,1,84,1,84,1,85,1,85,1,85,5,85,875,8,85,10,85,12,85,878,
        9,85,1,86,1,86,1,86,3,86,883,8,86,1,86,1,86,1,86,1,86,1,87,1,87,
        1,88,1,88,1,88,1,88,1,88,1,88,5,88,897,8,88,10,88,12,88,900,9,88,
        3,88,902,8,88,1,88,1,88,1,88,1,88,1,88,5,88,909,8,88,10,88,12,88,
        912,9,88,3,88,914,8,88,1,88,1,88,3,88,918,8,88,1,88,1,88,1,89,1,
        89,1,89,1,89,1,89,1,89,3,89,928,8,89,1,90,1,90,1,90,1,90,1,90,1,
        90,1,90,1,90,1,90,1,90,3,90,940,8,90,1,91,1,91,1,91,1,91,1,91,1,
        91,1,91,1,91,1,91,1,91,3,91,952,8,91,1,92,1,92,3,92,956,8,92,1,92,
        4,92,959,8,92,11,92,12,92,960,1,92,1,92,3,92,965,8,92,1,92,1,92,
        1,93,1,93,1,93,1,93,1,93,1,94,1,94,1,95,1,95,1,96,1,96,1,97,1,97,
        1,97,1,97,1,97,1,97,1,97,1,98,1,98,1,98,1,98,1,98,0,2,14,144,99,
        0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,
        46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,
        90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
        126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
        158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
        190,192,194,196,0,17,1,0,163,164,2,0,1,1,3,3,1,0,152,154,1,0,62,
        63,1,0,85,88,3,0,55,55,71,73,163,163,2,0,85,86,88,88,2,0,1,1,227,
        227,1,0,172,173,2,0,85,85,224,224,3,0,2,5,116,116,177,179,2,0,14,
        18,51,51,2,0,32,46,228,228,1,0,47,50,3,0,1,1,125,131,139,149,1,0,
        204,216,2,0,69,69,187,188,1036,0,201,1,0,0,0,2,222,1,0,0,0,4,224,
        1,0,0,0,6,226,1,0,0,0,8,272,1,0,0,0,10,285,1,0,0,0,12,287,1,0,0,
        0,14,295,1,0,0,0,16,332,1,0,0,0,18,334,1,0,0,0,20,336,1,0,0,0,22,
        338,1,0,0,0,24,340,1,0,0,0,26,349,1,0,0,0,28,362,1,0,0,0,30,364,
        1,0,0,0,32,372,1,0,0,0,34,374,1,0,0,0,36,382,1,0,0,0,38,384,1,0,
        0,0,40,392,1,0,0,0,42,396,1,0,0,0,44,398,1,0,0,0,46,407,1,0,0,0,
        48,409,1,0,0,0,50,423,1,0,0,0,52,434,1,0,0,0,54,442,1,0,0,0,56,457,
        1,0,0,0,58,461,1,0,0,0,60,468,1,0,0,0,62,500,1,0,0,0,64,502,1,0,
        0,0,66,512,1,0,0,0,68,526,1,0,0,0,70,528,1,0,0,0,72,542,1,0,0,0,
        74,584,1,0,0,0,76,586,1,0,0,0,78,588,1,0,0,0,80,590,1,0,0,0,82,611,
        1,0,0,0,84,613,1,0,0,0,86,615,1,0,0,0,88,617,1,0,0,0,90,629,1,0,
        0,0,92,638,1,0,0,0,94,659,1,0,0,0,96,661,1,0,0,0,98,663,1,0,0,0,
        100,665,1,0,0,0,102,667,1,0,0,0,104,689,1,0,0,0,106,691,1,0,0,0,
        108,722,1,0,0,0,110,724,1,0,0,0,112,728,1,0,0,0,114,730,1,0,0,0,
        116,738,1,0,0,0,118,746,1,0,0,0,120,748,1,0,0,0,122,750,1,0,0,0,
        124,758,1,0,0,0,126,760,1,0,0,0,128,768,1,0,0,0,130,772,1,0,0,0,
        132,781,1,0,0,0,134,785,1,0,0,0,136,787,1,0,0,0,138,792,1,0,0,0,
        140,794,1,0,0,0,142,796,1,0,0,0,144,812,1,0,0,0,146,827,1,0,0,0,
        148,829,1,0,0,0,150,834,1,0,0,0,152,838,1,0,0,0,154,840,1,0,0,0,
        156,842,1,0,0,0,158,847,1,0,0,0,160,849,1,0,0,0,162,851,1,0,0,0,
        164,853,1,0,0,0,166,867,1,0,0,0,168,869,1,0,0,0,170,871,1,0,0,0,
        172,879,1,0,0,0,174,888,1,0,0,0,176,890,1,0,0,0,178,927,1,0,0,0,
        180,939,1,0,0,0,182,951,1,0,0,0,184,953,1,0,0,0,186,968,1,0,0,0,
        188,973,1,0,0,0,190,975,1,0,0,0,192,977,1,0,0,0,194,979,1,0,0,0,
        196,986,1,0,0,0,198,200,3,2,1,0,199,198,1,0,0,0,200,203,1,0,0,0,
        201,199,1,0,0,0,201,202,1,0,0,0,202,204,1,0,0,0,203,201,1,0,0,0,
        204,205,5,0,0,1,205,1,1,0,0,0,206,223,3,6,3,0,207,223,3,48,24,0,
        208,223,3,54,27,0,209,223,3,58,29,0,210,223,3,60,30,0,211,223,3,
        68,34,0,212,223,3,102,51,0,213,223,3,110,55,0,214,223,3,114,57,0,
        215,223,3,126,63,0,216,223,3,128,64,0,217,223,3,130,65,0,218,223,
        3,132,66,0,219,223,3,136,68,0,220,223,3,142,71,0,221,223,3,4,2,0,
        222,206,1,0,0,0,222,207,1,0,0,0,222,208,1,0,0,0,222,209,1,0,0,0,
        222,210,1,0,0,0,222,211,1,0,0,0,222,212,1,0,0,0,222,213,1,0,0,0,
        222,214,1,0,0,0,222,215,1,0,0,0,222,216,1,0,0,0,222,217,1,0,0,0,
        222,218,1,0,0,0,222,219,1,0,0,0,222,220,1,0,0,0,222,221,1,0,0,0,
        223,3,1,0,0,0,224,225,5,11,0,0,225,5,1,0,0,0,226,228,5,55,0,0,227,
        229,7,0,0,0,228,227,1,0,0,0,228,229,1,0,0,0,229,230,1,0,0,0,230,
        231,3,8,4,0,231,232,5,56,0,0,232,235,3,14,7,0,233,234,5,57,0,0,234,
        236,3,32,16,0,235,233,1,0,0,0,235,236,1,0,0,0,236,240,1,0,0,0,237,
        238,5,58,0,0,238,239,5,59,0,0,239,241,3,34,17,0,240,237,1,0,0,0,
        240,241,1,0,0,0,241,244,1,0,0,0,242,243,5,60,0,0,243,245,3,36,18,
        0,244,242,1,0,0,0,244,245,1,0,0,0,245,249,1,0,0,0,246,247,5,61,0,
        0,247,248,5,59,0,0,248,250,3,38,19,0,249,246,1,0,0,0,249,250,1,0,
        0,0,250,253,1,0,0,0,251,252,5,64,0,0,252,254,3,42,21,0,253,251,1,
        0,0,0,253,254,1,0,0,0,254,257,1,0,0,0,255,256,5,65,0,0,256,258,3,
        44,22,0,257,255,1,0,0,0,257,258,1,0,0,0,258,261,1,0,0,0,259,260,
        5,66,0,0,260,262,3,46,23,0,261,259,1,0,0,0,261,262,1,0,0,0,262,7,
        1,0,0,0,263,268,3,10,5,0,264,265,5,10,0,0,265,267,3,10,5,0,266,264,
        1,0,0,0,267,270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,273,
        1,0,0,0,270,268,1,0,0,0,271,273,5,16,0,0,272,263,1,0,0,0,272,271,
        1,0,0,0,273,9,1,0,0,0,274,279,3,144,72,0,275,277,5,217,0,0,276,275,
        1,0,0,0,276,277,1,0,0,0,277,278,1,0,0,0,278,280,3,12,6,0,279,276,
        1,0,0,0,279,280,1,0,0,0,280,286,1,0,0,0,281,282,3,152,76,0,282,283,
        5,22,0,0,283,284,5,16,0,0,284,286,1,0,0,0,285,274,1,0,0,0,285,281,
        1,0,0,0,286,11,1,0,0,0,287,288,7,1,0,0,288,13,1,0,0,0,289,290,6,
        7,-1,0,290,296,3,16,8,0,291,292,5,6,0,0,292,293,3,14,7,0,293,294,
        5,7,0,0,294,296,1,0,0,0,295,289,1,0,0,0,295,291,1,0,0,0,296,301,
        1,0,0,0,297,298,10,2,0,0,298,300,3,26,13,0,299,297,1,0,0,0,300,303,
        1,0,0,0,301,299,1,0,0,0,301,302,1,0,0,0,302,15,1,0,0,0,303,301,1,
        0,0,0,304,309,3,152,76,0,305,307,5,217,0,0,306,305,1,0,0,0,306,307,
        1,0,0,0,307,308,1,0,0,0,308,310,3,12,6,0,309,306,1,0,0,0,309,310,
        1,0,0,0,310,333,1,0,0,0,311,312,5,6,0,0,312,313,3,6,3,0,313,318,
        5,7,0,0,314,316,5,217,0,0,315,314,1,0,0,0,315,316,1,0,0,0,316,317,
        1,0,0,0,317,319,3,12,6,0,318,315,1,0,0,0,318,319,1,0,0,0,319,333,
        1,0,0,0,320,321,3,18,9,0,321,323,5,6,0,0,322,324,3,52,26,0,323,322,
        1,0,0,0,323,324,1,0,0,0,324,325,1,0,0,0,325,330,5,7,0,0,326,328,
        5,217,0,0,327,326,1,0,0,0,327,328,1,0,0,0,328,329,1,0,0,0,329,331,
        3,12,6,0,330,327,1,0,0,0,330,331,1,0,0,0,331,333,1,0,0,0,332,304,
        1,0,0,0,332,311,1,0,0,0,332,320,1,0,0,0,333,17,1,0,0,0,334,335,5,
        1,0,0,335,19,1,0,0,0,336,337,5,1,0,0,337,21,1,0,0,0,338,339,5,1,
        0,0,339,23,1,0,0,0,340,341,5,1,0,0,341,25,1,0,0,0,342,350,5,151,
        0,0,343,345,7,2,0,0,344,346,5,155,0,0,345,344,1,0,0,0,345,346,1,
        0,0,0,346,350,1,0,0,0,347,350,5,156,0,0,348,350,5,157,0,0,349,342,
        1,0,0,0,349,343,1,0,0,0,349,347,1,0,0,0,349,348,1,0,0,0,349,350,
        1,0,0,0,350,351,1,0,0,0,351,352,5,150,0,0,352,360,3,16,8,0,353,354,
        5,159,0,0,354,361,3,28,14,0,355,356,5,158,0,0,356,357,5,6,0,0,357,
        358,3,30,15,0,358,359,5,7,0,0,359,361,1,0,0,0,360,353,1,0,0,0,360,
        355,1,0,0,0,360,361,1,0,0,0,361,27,1,0,0,0,362,363,3,144,72,0,363,
        29,1,0,0,0,364,369,3,154,77,0,365,366,5,10,0,0,366,368,3,154,77,
        0,367,365,1,0,0,0,368,371,1,0,0,0,369,367,1,0,0,0,369,370,1,0,0,
        0,370,31,1,0,0,0,371,369,1,0,0,0,372,373,3,144,72,0,373,33,1,0,0,
        0,374,379,3,144,72,0,375,376,5,10,0,0,376,378,3,144,72,0,377,375,
        1,0,0,0,378,381,1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,0,380,35,1,
        0,0,0,381,379,1,0,0,0,382,383,3,144,72,0,383,37,1,0,0,0,384,389,
        3,40,20,0,385,386,5,10,0,0,386,388,3,40,20,0,387,385,1,0,0,0,388,
        391,1,0,0,0,389,387,1,0,0,0,389,390,1,0,0,0,390,39,1,0,0,0,391,389,
        1,0,0,0,392,394,3,144,72,0,393,395,7,3,0,0,394,393,1,0,0,0,394,395,
        1,0,0,0,395,41,1,0,0,0,396,397,5,2,0,0,397,43,1,0,0,0,398,399,5,
        2,0,0,399,45,1,0,0,0,400,408,5,67,0,0,401,402,5,68,0,0,402,404,5,
        2,0,0,403,405,5,69,0,0,404,403,1,0,0,0,404,405,1,0,0,0,405,406,1,
        0,0,0,406,408,5,70,0,0,407,400,1,0,0,0,407,401,1,0,0,0,408,47,1,
        0,0,0,409,410,5,71,0,0,410,411,5,77,0,0,411,416,3,152,76,0,412,413,
        5,6,0,0,413,414,3,30,15,0,414,415,5,7,0,0,415,417,1,0,0,0,416,412,
        1,0,0,0,416,417,1,0,0,0,417,421,1,0,0,0,418,419,5,75,0,0,419,422,
        3,50,25,0,420,422,3,6,3,0,421,418,1,0,0,0,421,420,1,0,0,0,422,49,
        1,0,0,0,423,424,5,6,0,0,424,429,3,144,72,0,425,426,5,10,0,0,426,
        428,3,144,72,0,427,425,1,0,0,0,428,431,1,0,0,0,429,427,1,0,0,0,429,
        430,1,0,0,0,430,432,1,0,0,0,431,429,1,0,0,0,432,433,5,7,0,0,433,
        51,1,0,0,0,434,439,3,144,72,0,435,436,5,10,0,0,436,438,3,144,72,
        0,437,435,1,0,0,0,438,441,1,0,0,0,439,437,1,0,0,0,439,440,1,0,0,
        0,440,53,1,0,0,0,441,439,1,0,0,0,442,443,5,72,0,0,443,444,3,152,
        76,0,444,445,5,76,0,0,445,450,3,56,28,0,446,447,5,10,0,0,447,449,
        3,56,28,0,448,446,1,0,0,0,449,452,1,0,0,0,450,448,1,0,0,0,450,451,
        1,0,0,0,451,455,1,0,0,0,452,450,1,0,0,0,453,454,5,57,0,0,454,456,
        3,32,16,0,455,453,1,0,0,0,455,456,1,0,0,0,456,55,1,0,0,0,457,458,
        3,154,77,0,458,459,5,13,0,0,459,460,3,144,72,0,460,57,1,0,0,0,461,
        462,5,73,0,0,462,463,5,56,0,0,463,466,3,152,76,0,464,465,5,57,0,
        0,465,467,3,32,16,0,466,464,1,0,0,0,466,467,1,0,0,0,467,59,1,0,0,
        0,468,469,5,74,0,0,469,470,5,77,0,0,470,475,3,152,76,0,471,473,5,
        217,0,0,472,471,1,0,0,0,472,473,1,0,0,0,473,474,1,0,0,0,474,476,
        3,12,6,0,475,472,1,0,0,0,475,476,1,0,0,0,476,477,1,0,0,0,477,478,
        5,158,0,0,478,483,3,16,8,0,479,481,5,217,0,0,480,479,1,0,0,0,480,
        481,1,0,0,0,481,482,1,0,0,0,482,484,3,12,6,0,483,480,1,0,0,0,483,
        484,1,0,0,0,484,485,1,0,0,0,485,486,5,159,0,0,486,491,3,62,31,0,
        487,488,5,133,0,0,488,489,5,218,0,0,489,490,5,134,0,0,490,492,3,
        64,32,0,491,487,1,0,0,0,491,492,1,0,0,0,492,498,1,0,0,0,493,494,
        5,133,0,0,494,495,5,49,0,0,495,496,5,218,0,0,496,497,5,134,0,0,497,
        499,3,66,33,0,498,493,1,0,0,0,498,499,1,0,0,0,499,61,1,0,0,0,500,
        501,3,144,72,0,501,63,1,0,0,0,502,503,5,72,0,0,503,504,5,76,0,0,
        504,509,3,56,28,0,505,506,5,10,0,0,506,508,3,56,28,0,507,505,1,0,
        0,0,508,511,1,0,0,0,509,507,1,0,0,0,509,510,1,0,0,0,510,65,1,0,0,
        0,511,509,1,0,0,0,512,517,5,71,0,0,513,514,5,6,0,0,514,515,3,30,
        15,0,515,516,5,7,0,0,516,518,1,0,0,0,517,513,1,0,0,0,517,518,1,0,
        0,0,518,519,1,0,0,0,519,520,5,75,0,0,520,521,3,50,25,0,521,67,1,
        0,0,0,522,527,3,70,35,0,523,527,3,88,44,0,524,527,3,90,45,0,525,
        527,3,92,46,0,526,522,1,0,0,0,526,523,1,0,0,0,526,524,1,0,0,0,526,
        525,1,0,0,0,527,69,1,0,0,0,528,529,5,78,0,0,529,530,5,85,0,0,530,
        531,3,152,76,0,531,532,5,6,0,0,532,537,3,72,36,0,533,534,5,10,0,
        0,534,536,3,72,36,0,535,533,1,0,0,0,536,539,1,0,0,0,537,535,1,0,
        0,0,537,538,1,0,0,0,538,540,1,0,0,0,539,537,1,0,0,0,540,541,5,7,
        0,0,541,71,1,0,0,0,542,543,3,154,77,0,543,547,3,74,37,0,544,546,
        3,82,41,0,545,544,1,0,0,0,546,549,1,0,0,0,547,545,1,0,0,0,547,548,
        1,0,0,0,548,73,1,0,0,0,549,547,1,0,0,0,550,585,5,93,0,0,551,585,
        5,94,0,0,552,585,5,95,0,0,553,562,5,96,0,0,554,555,5,6,0,0,555,558,
        3,76,38,0,556,557,5,10,0,0,557,559,3,78,39,0,558,556,1,0,0,0,558,
        559,1,0,0,0,559,560,1,0,0,0,560,561,5,7,0,0,561,563,1,0,0,0,562,
        554,1,0,0,0,562,563,1,0,0,0,563,585,1,0,0,0,564,585,5,97,0,0,565,
        585,5,98,0,0,566,585,5,99,0,0,567,572,5,100,0,0,568,569,5,6,0,0,
        569,570,3,80,40,0,570,571,5,7,0,0,571,573,1,0,0,0,572,568,1,0,0,
        0,572,573,1,0,0,0,573,585,1,0,0,0,574,579,5,101,0,0,575,576,5,6,
        0,0,576,577,3,80,40,0,577,578,5,7,0,0,578,580,1,0,0,0,579,575,1,
        0,0,0,579,580,1,0,0,0,580,585,1,0,0,0,581,585,5,107,0,0,582,585,
        5,108,0,0,583,585,5,109,0,0,584,550,1,0,0,0,584,551,1,0,0,0,584,
        552,1,0,0,0,584,553,1,0,0,0,584,564,1,0,0,0,584,565,1,0,0,0,584,
        566,1,0,0,0,584,567,1,0,0,0,584,574,1,0,0,0,584,581,1,0,0,0,584,
        582,1,0,0,0,584,583,1,0,0,0,585,75,1,0,0,0,586,587,5,2,0,0,587,77,
        1,0,0,0,588,589,5,2,0,0,589,79,1,0,0,0,590,591,5,2,0,0,591,81,1,
        0,0,0,592,612,5,115,0,0,593,594,5,117,0,0,594,612,3,84,42,0,595,
        596,5,111,0,0,596,612,5,113,0,0,597,612,5,114,0,0,598,599,5,118,
        0,0,599,600,5,6,0,0,600,601,3,86,43,0,601,602,5,7,0,0,602,612,1,
        0,0,0,603,604,5,120,0,0,604,609,3,152,76,0,605,606,5,6,0,0,606,607,
        3,154,77,0,607,608,5,7,0,0,608,610,1,0,0,0,609,605,1,0,0,0,609,610,
        1,0,0,0,610,612,1,0,0,0,611,592,1,0,0,0,611,593,1,0,0,0,611,595,
        1,0,0,0,611,597,1,0,0,0,611,598,1,0,0,0,611,603,1,0,0,0,612,83,1,
        0,0,0,613,614,3,144,72,0,614,85,1,0,0,0,615,616,3,144,72,0,616,87,
        1,0,0,0,617,618,5,78,0,0,618,619,5,86,0,0,619,624,5,1,0,0,620,621,
        5,6,0,0,621,622,3,30,15,0,622,623,5,7,0,0,623,625,1,0,0,0,624,620,
        1,0,0,0,624,625,1,0,0,0,625,626,1,0,0,0,626,627,5,217,0,0,627,628,
        3,6,3,0,628,89,1,0,0,0,629,630,5,78,0,0,630,631,5,87,0,0,631,632,
        5,1,0,0,632,633,5,159,0,0,633,634,3,152,76,0,634,635,5,6,0,0,635,
        636,3,30,15,0,636,637,5,7,0,0,637,91,1,0,0,0,638,639,5,78,0,0,639,
        640,5,88,0,0,640,644,5,1,0,0,641,642,5,219,0,0,642,643,5,184,0,0,
        643,645,3,94,47,0,644,641,1,0,0,0,644,645,1,0,0,0,645,649,1,0,0,
        0,646,647,5,220,0,0,647,648,5,59,0,0,648,650,3,96,48,0,649,646,1,
        0,0,0,649,650,1,0,0,0,650,653,1,0,0,0,651,652,5,221,0,0,652,654,
        3,98,49,0,653,651,1,0,0,0,653,654,1,0,0,0,654,657,1,0,0,0,655,656,
        5,222,0,0,656,658,3,100,50,0,657,655,1,0,0,0,657,658,1,0,0,0,658,
        93,1,0,0,0,659,660,5,2,0,0,660,95,1,0,0,0,661,662,5,2,0,0,662,97,
        1,0,0,0,663,664,5,2,0,0,664,99,1,0,0,0,665,666,5,2,0,0,666,101,1,
        0,0,0,667,668,5,79,0,0,668,669,5,85,0,0,669,670,3,152,76,0,670,671,
        3,104,52,0,671,103,1,0,0,0,672,673,5,223,0,0,673,674,5,224,0,0,674,
        690,3,72,36,0,675,676,5,80,0,0,676,677,5,224,0,0,677,690,3,154,77,
        0,678,679,5,225,0,0,679,680,5,224,0,0,680,690,3,72,36,0,681,682,
        5,223,0,0,682,683,5,119,0,0,683,684,3,106,53,0,684,685,3,108,54,
        0,685,690,1,0,0,0,686,687,5,80,0,0,687,688,5,119,0,0,688,690,3,106,
        53,0,689,672,1,0,0,0,689,675,1,0,0,0,689,678,1,0,0,0,689,681,1,0,
        0,0,689,686,1,0,0,0,690,105,1,0,0,0,691,692,5,1,0,0,692,107,1,0,
        0,0,693,694,5,111,0,0,694,695,5,113,0,0,695,696,5,6,0,0,696,697,
        3,30,15,0,697,698,5,7,0,0,698,723,1,0,0,0,699,700,5,114,0,0,700,
        701,5,6,0,0,701,702,3,30,15,0,702,703,5,7,0,0,703,723,1,0,0,0,704,
        705,5,112,0,0,705,706,5,113,0,0,706,707,5,6,0,0,707,708,3,30,15,
        0,708,709,5,7,0,0,709,710,5,120,0,0,710,715,3,152,76,0,711,712,5,
        6,0,0,712,713,3,30,15,0,713,714,5,7,0,0,714,716,1,0,0,0,715,711,
        1,0,0,0,715,716,1,0,0,0,716,723,1,0,0,0,717,718,5,118,0,0,718,719,
        5,6,0,0,719,720,3,86,43,0,720,721,5,7,0,0,721,723,1,0,0,0,722,693,
        1,0,0,0,722,699,1,0,0,0,722,704,1,0,0,0,722,717,1,0,0,0,723,109,
        1,0,0,0,724,725,5,80,0,0,725,726,7,4,0,0,726,727,3,112,56,0,727,
        111,1,0,0,0,728,729,5,1,0,0,729,113,1,0,0,0,730,731,5,83,0,0,731,
        732,3,116,58,0,732,733,5,159,0,0,733,734,3,120,60,0,734,735,3,112,
        56,0,735,736,5,226,0,0,736,737,3,122,61,0,737,115,1,0,0,0,738,743,
        3,118,59,0,739,740,5,10,0,0,740,742,3,118,59,0,741,739,1,0,0,0,742,
        745,1,0,0,0,743,741,1,0,0,0,743,744,1,0,0,0,744,117,1,0,0,0,745,
        743,1,0,0,0,746,747,7,5,0,0,747,119,1,0,0,0,748,749,7,6,0,0,749,
        121,1,0,0,0,750,755,3,124,62,0,751,752,5,10,0,0,752,754,3,124,62,
        0,753,751,1,0,0,0,754,757,1,0,0,0,755,753,1,0,0,0,755,756,1,0,0,
        0,756,123,1,0,0,0,757,755,1,0,0,0,758,759,7,7,0,0,759,125,1,0,0,
        0,760,761,5,84,0,0,761,762,3,116,58,0,762,763,5,159,0,0,763,764,
        3,120,60,0,764,765,3,112,56,0,765,766,5,56,0,0,766,767,3,122,61,
        0,767,127,1,0,0,0,768,770,5,168,0,0,769,771,5,172,0,0,770,769,1,
        0,0,0,770,771,1,0,0,0,771,129,1,0,0,0,772,774,5,169,0,0,773,775,
        5,172,0,0,774,773,1,0,0,0,774,775,1,0,0,0,775,779,1,0,0,0,776,777,
        5,226,0,0,777,778,5,170,0,0,778,780,3,134,67,0,779,776,1,0,0,0,779,
        780,1,0,0,0,780,131,1,0,0,0,781,783,5,167,0,0,782,784,7,8,0,0,783,
        782,1,0,0,0,783,784,1,0,0,0,784,133,1,0,0,0,785,786,5,1,0,0,786,
        135,1,0,0,0,787,788,5,76,0,0,788,789,3,138,69,0,789,790,5,13,0,0,
        790,791,3,140,70,0,791,137,1,0,0,0,792,793,5,1,0,0,793,139,1,0,0,
        0,794,795,3,144,72,0,795,141,1,0,0,0,796,797,5,53,0,0,797,798,5,
        159,0,0,798,799,7,9,0,0,799,800,3,112,56,0,800,801,5,43,0,0,801,
        802,5,3,0,0,802,143,1,0,0,0,803,804,6,72,-1,0,804,813,3,146,73,0,
        805,806,5,6,0,0,806,807,3,144,72,0,807,808,5,7,0,0,808,813,1,0,0,
        0,809,813,3,166,83,0,810,813,3,184,92,0,811,813,3,194,97,0,812,803,
        1,0,0,0,812,805,1,0,0,0,812,809,1,0,0,0,812,810,1,0,0,0,812,811,
        1,0,0,0,813,820,1,0,0,0,814,815,10,5,0,0,815,816,3,158,79,0,816,
        817,3,144,72,6,817,819,1,0,0,0,818,814,1,0,0,0,819,822,1,0,0,0,820,
        818,1,0,0,0,820,821,1,0,0,0,821,145,1,0,0,0,822,820,1,0,0,0,823,
        828,3,148,74,0,824,828,3,150,75,0,825,828,3,156,78,0,826,828,3,196,
        98,0,827,823,1,0,0,0,827,824,1,0,0,0,827,825,1,0,0,0,827,826,1,0,
        0,0,828,147,1,0,0,0,829,830,7,10,0,0,830,149,1,0,0,0,831,832,3,152,
        76,0,832,833,5,22,0,0,833,835,1,0,0,0,834,831,1,0,0,0,834,835,1,
        0,0,0,835,836,1,0,0,0,836,837,3,154,77,0,837,151,1,0,0,0,838,839,
        5,1,0,0,839,153,1,0,0,0,840,841,5,1,0,0,841,155,1,0,0,0,842,843,
        5,24,0,0,843,157,1,0,0,0,844,848,3,160,80,0,845,848,3,162,81,0,846,
        848,3,164,82,0,847,844,1,0,0,0,847,845,1,0,0,0,847,846,1,0,0,0,848,
        159,1,0,0,0,849,850,7,11,0,0,850,161,1,0,0,0,851,852,7,12,0,0,852,
        163,1,0,0,0,853,854,7,13,0,0,854,165,1,0,0,0,855,856,3,168,84,0,
        856,858,5,6,0,0,857,859,7,0,0,0,858,857,1,0,0,0,858,859,1,0,0,0,
        859,862,1,0,0,0,860,863,3,170,85,0,861,863,5,16,0,0,862,860,1,0,
        0,0,862,861,1,0,0,0,862,863,1,0,0,0,863,864,1,0,0,0,864,865,5,7,
        0,0,865,868,1,0,0,0,866,868,3,172,86,0,867,855,1,0,0,0,867,866,1,
        0,0,0,868,167,1,0,0,0,869,870,7,14,0,0,870,169,1,0,0,0,871,876,3,
        144,72,0,872,873,5,10,0,0,873,875,3,144,72,0,874,872,1,0,0,0,875,
        878,1,0,0,0,876,874,1,0,0,0,876,877,1,0,0,0,877,171,1,0,0,0,878,
        876,1,0,0,0,879,880,3,174,87,0,880,882,5,6,0,0,881,883,3,170,85,
        0,882,881,1,0,0,0,882,883,1,0,0,0,883,884,1,0,0,0,884,885,5,7,0,
        0,885,886,5,194,0,0,886,887,3,176,88,0,887,173,1,0,0,0,888,889,7,
        15,0,0,889,175,1,0,0,0,890,901,5,6,0,0,891,892,5,92,0,0,892,893,
        5,59,0,0,893,898,3,144,72,0,894,895,5,10,0,0,895,897,3,144,72,0,
        896,894,1,0,0,0,897,900,1,0,0,0,898,896,1,0,0,0,898,899,1,0,0,0,
        899,902,1,0,0,0,900,898,1,0,0,0,901,891,1,0,0,0,901,902,1,0,0,0,
        902,913,1,0,0,0,903,904,5,61,0,0,904,905,5,59,0,0,905,910,3,40,20,
        0,906,907,5,10,0,0,907,909,3,40,20,0,908,906,1,0,0,0,909,912,1,0,
        0,0,910,908,1,0,0,0,910,911,1,0,0,0,911,914,1,0,0,0,912,910,1,0,
        0,0,913,903,1,0,0,0,913,914,1,0,0,0,914,915,1,0,0,0,915,917,7,16,
        0,0,916,918,3,178,89,0,917,916,1,0,0,0,917,918,1,0,0,0,918,919,1,
        0,0,0,919,920,5,7,0,0,920,177,1,0,0,0,921,928,3,180,90,0,922,923,
        5,41,0,0,923,924,3,180,90,0,924,925,5,47,0,0,925,926,3,182,91,0,
        926,928,1,0,0,0,927,921,1,0,0,0,927,922,1,0,0,0,928,179,1,0,0,0,
        929,930,5,189,0,0,930,940,5,190,0,0,931,932,5,192,0,0,932,940,5,
        193,0,0,933,934,3,144,72,0,934,935,5,190,0,0,935,940,1,0,0,0,936,
        937,3,144,72,0,937,938,5,191,0,0,938,940,1,0,0,0,939,929,1,0,0,0,
        939,931,1,0,0,0,939,933,1,0,0,0,939,936,1,0,0,0,940,181,1,0,0,0,
        941,942,5,189,0,0,942,952,5,191,0,0,943,944,5,192,0,0,944,952,5,
        193,0,0,945,946,3,144,72,0,946,947,5,190,0,0,947,952,1,0,0,0,948,
        949,3,144,72,0,949,950,5,191,0,0,950,952,1,0,0,0,951,941,1,0,0,0,
        951,943,1,0,0,0,951,945,1,0,0,0,951,948,1,0,0,0,952,183,1,0,0,0,
        953,955,5,132,0,0,954,956,3,144,72,0,955,954,1,0,0,0,955,956,1,0,
        0,0,956,958,1,0,0,0,957,959,3,186,93,0,958,957,1,0,0,0,959,960,1,
        0,0,0,960,958,1,0,0,0,960,961,1,0,0,0,961,964,1,0,0,0,962,963,5,
        135,0,0,963,965,3,192,96,0,964,962,1,0,0,0,964,965,1,0,0,0,965,966,
        1,0,0,0,966,967,5,136,0,0,967,185,1,0,0,0,968,969,5,133,0,0,969,
        970,3,188,94,0,970,971,5,134,0,0,971,972,3,190,95,0,972,187,1,0,
        0,0,973,974,3,144,72,0,974,189,1,0,0,0,975,976,3,144,72,0,976,191,
        1,0,0,0,977,978,3,144,72,0,978,193,1,0,0,0,979,980,5,137,0,0,980,
        981,5,6,0,0,981,982,3,144,72,0,982,983,5,217,0,0,983,984,3,74,37,
        0,984,985,5,7,0,0,985,195,1,0,0,0,986,987,5,6,0,0,987,988,3,6,3,
        0,988,989,5,7,0,0,989,197,1,0,0,0,94,201,222,228,235,240,244,249,
        253,257,261,268,272,276,279,285,295,301,306,309,315,318,323,327,
        330,332,345,349,360,369,379,389,394,404,407,416,421,429,439,450,
        455,466,472,475,480,483,491,498,509,517,526,537,547,558,562,572,
        579,584,609,611,624,644,649,653,657,689,715,722,743,755,770,774,
        779,783,812,820,827,834,847,858,862,867,876,882,898,901,910,913,
        917,927,939,951,955,960,964
    ]

class db2_parser ( Parser ):

    grammarFileName = "db2_parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'('", "')'", "'['", "']'", 
                     "','", "';'", "':'", "'='", "'+'", "'-'", "'*'", "'/'", 
                     "'%'", "'#'", "'@'", "'$'", "'.'", "'_'", "'?'", "'!'", 
                     "'~'", "'^'", "'&'", "'|'", "'\\'", "'`'", "<INVALID>", 
                     "'>'", "'<'", "'>='", "'<='", "'LIKE'", "<INVALID>", 
                     "'IN'", "<INVALID>", "'BETWEEN'", "<INVALID>", "'IS'", 
                     "<INVALID>", "'EXISTS'", "<INVALID>", "'AND'", "'OR'", 
                     "'NOT'", "'XOR'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'SELECT'", "'FROM'", "'WHERE'", "'GROUP'", 
                     "'BY'", "'HAVING'", "'ORDER'", "'ASC'", "'DESC'", "'LIMIT'", 
                     "'OFFSET'", "'FETCH'", "'FIRST'", "'NEXT'", "'ROWS'", 
                     "'ONLY'", "'INSERT'", "'UPDATE'", "'DELETE'", "'MERGE'", 
                     "'VALUES'", "'SET'", "'INTO'", "'CREATE'", "'ALTER'", 
                     "'DROP'", "'TRUNCATE'", "'RENAME'", "'GRANT'", "'REVOKE'", 
                     "'TABLE'", "'VIEW'", "'INDEX'", "'SEQUENCE'", "'SCHEMA'", 
                     "'DATABASE'", "'TABLESPACE'", "'PARTITION'", "<INVALID>", 
                     "'SMALLINT'", "'BIGINT'", "<INVALID>", "'REAL'", "<INVALID>", 
                     "'FLOAT'", "<INVALID>", "<INVALID>", "<INVALID>", "'GRAPHIC'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'DATE'", "'TIME'", 
                     "'TIMESTAMP'", "'XML'", "'PRIMARY'", "'FOREIGN'", "'KEY'", 
                     "'UNIQUE'", "<INVALID>", "'NULL'", "'DEFAULT'", "'CHECK'", 
                     "'CONSTRAINT'", "'REFERENCES'", "'CASCADE'", "'RESTRICT'", 
                     "<INVALID>", "<INVALID>", "'COUNT'", "'SUM'", "<INVALID>", 
                     "'MIN'", "'MAX'", "'COALESCE'", "'NULLIF'", "'CASE'", 
                     "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'CAST'", "'CONVERT'", 
                     "<INVALID>", "<INVALID>", "'UPPER'", "'LOWER'", "'TRIM'", 
                     "'LTRIM'", "'RTRIM'", "'REPLACE'", "'TRANSLATE'", "<INVALID>", 
                     "'LOCATE'", "'JOIN'", "'INNER'", "'LEFT'", "'RIGHT'", 
                     "'FULL'", "'OUTER'", "'CROSS'", "'NATURAL'", "'USING'", 
                     "'ON'", "'UNION'", "'INTERSECT'", "'EXCEPT'", "'ALL'", 
                     "'DISTINCT'", "'ANY'", "'SOME'", "'BEGIN'", "'COMMIT'", 
                     "'ROLLBACK'", "'SAVEPOINT'", "'RELEASE'", "'WORK'", 
                     "'TRANSACTION'", "'CONNECT'", "'DISCONNECT'", "'RESET'", 
                     "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
                     "'CURRENT_USER'", "'USER'", "'SYSTEM_USER'", "'SESSION_USER'", 
                     "'WITH'", "'RECURSIVE'", "'LATERAL'", "'RANGE'", "'GROUPS'", 
                     "'UNBOUNDED'", "'PRECEDING'", "'FOLLOWING'", "'CURRENT'", 
                     "'ROW'", "'OVER'", "'WINDOW'", "'FRAME'", "'EXCLUDE'", 
                     "'TIES'", "'RESPECT'", "'IGNORE'", "'NULLS'", "'LAST'", 
                     "'KEEP'", "'DENSE_RANK'", "'RANK'", "'ROW_NUMBER'", 
                     "'NTILE'", "'LAG'", "'LEAD'", "'FIRST_VALUE'", "'LAST_VALUE'", 
                     "'NTH_VALUE'", "'PERCENT_RANK'", "'CUME_DIST'", "'PERCENTILE_CONT'", 
                     "'PERCENTILE_DISC'" ]

    symbolicNames = [ "<INVALID>", "IDENTIFIER", "NUMBER", "STRING", "DOUBLE_QUOTED_STRING", 
                      "HEX_STRING", "LPAREN", "RPAREN", "LBRACKET", "RBRACKET", 
                      "COMMA", "SEMICOLON", "COLON", "EQUALS", "PLUS", "MINUS", 
                      "ASTERISK", "SLASH", "PERCENT", "HASH", "AT", "DOLLAR", 
                      "DOT", "UNDERSCORE", "QUESTION", "EXCLAMATION", "TILDE", 
                      "CARET", "AMPERSAND", "PIPE", "BACKSLASH", "GRAVE", 
                      "NE", "GT", "LT", "GE", "LE", "LIKE", "NOT_LIKE", 
                      "IN", "NOT_IN", "BETWEEN", "NOT_BETWEEN", "IS", "IS_NOT", 
                      "EXISTS", "NOT_EXISTS", "AND", "OR", "NOT", "XOR", 
                      "POWER", "WS", "COMMENT", "LINE_COMMENT", "SELECT", 
                      "FROM", "WHERE", "GROUP", "BY", "HAVING", "ORDER", 
                      "ASC", "DESC", "LIMIT", "OFFSET", "FETCH", "FIRST", 
                      "NEXT", "ROWS", "ONLY", "INSERT", "UPDATE", "DELETE", 
                      "MERGE", "VALUES", "SET", "INTO", "CREATE", "ALTER", 
                      "DROP", "TRUNCATE", "RENAME", "GRANT", "REVOKE", "TABLE", 
                      "VIEW", "INDEX", "SEQUENCE", "SCHEMA", "DATABASE", 
                      "TABLESPACE", "PARTITION", "INTEGER", "SMALLINT", 
                      "BIGINT", "DECIMAL", "REAL", "DOUBLE", "FLOAT", "CHAR", 
                      "VARCHAR", "CLOB", "GRAPHIC", "VARGRAPHIC", "DBCLOB", 
                      "BLOB", "DATE", "TIME", "TIMESTAMP", "XML", "PRIMARY", 
                      "FOREIGN", "KEY", "UNIQUE", "NOT_NULL", "NULL", "DEFAULT", 
                      "CHECK", "CONSTRAINT", "REFERENCES", "CASCADE", "RESTRICT", 
                      "SET_NULL", "NO_ACTION", "COUNT", "SUM", "AVG", "MIN", 
                      "MAX", "COALESCE", "NULLIF", "CASE", "WHEN", "THEN", 
                      "ELSE", "END", "CAST", "CONVERT", "SUBSTRING", "LENGTH", 
                      "UPPER", "LOWER", "TRIM", "LTRIM", "RTRIM", "REPLACE", 
                      "TRANSLATE", "POSITION", "LOCATE", "JOIN", "INNER", 
                      "LEFT", "RIGHT", "FULL", "OUTER", "CROSS", "NATURAL", 
                      "USING", "ON", "UNION", "INTERSECT", "EXCEPT", "ALL", 
                      "DISTINCT", "ANY", "SOME", "BEGIN", "COMMIT", "ROLLBACK", 
                      "SAVEPOINT", "RELEASE", "WORK", "TRANSACTION", "CONNECT", 
                      "DISCONNECT", "RESET", "CURRENT_DATE", "CURRENT_TIME", 
                      "CURRENT_TIMESTAMP", "CURRENT_USER", "USER", "SYSTEM_USER", 
                      "SESSION_USER", "WITH", "RECURSIVE", "LATERAL", "RANGE", 
                      "GROUPS", "UNBOUNDED", "PRECEDING", "FOLLOWING", "CURRENT", 
                      "ROW", "OVER", "WINDOW", "FRAME", "EXCLUDE", "TIES", 
                      "RESPECT", "IGNORE", "NULLS", "LAST", "KEEP", "DENSE_RANK", 
                      "RANK", "ROW_NUMBER", "NTILE", "LAG", "LEAD", "FIRST_VALUE", 
                      "LAST_VALUE", "NTH_VALUE", "PERCENT_RANK", "CUME_DIST", 
                      "PERCENTILE_CONT", "PERCENTILE_DISC", "AS", "MATCHED", 
                      "START", "INCREMENT", "MINVALUE", "MAXVALUE", "ADD", 
                      "COLUMN", "MODIFY", "TO", "PUBLIC", "EQ" ]

    RULE_sqlScript = 0
    RULE_sqlStatement = 1
    RULE_semicolon = 2
    RULE_selectStatement = 3
    RULE_selectList = 4
    RULE_selectItem = 5
    RULE_alias = 6
    RULE_tableExpression = 7
    RULE_tableReference = 8
    RULE_tableFunctionName = 9
    RULE_viewName = 10
    RULE_indexName = 11
    RULE_sequenceName = 12
    RULE_joinClause = 13
    RULE_joinCondition = 14
    RULE_columnList = 15
    RULE_whereClause = 16
    RULE_groupByClause = 17
    RULE_havingClause = 18
    RULE_orderByClause = 19
    RULE_orderByItem = 20
    RULE_limitClause = 21
    RULE_offsetClause = 22
    RULE_fetchClause = 23
    RULE_insertStatement = 24
    RULE_valueList = 25
    RULE_arguments = 26
    RULE_updateStatement = 27
    RULE_setClause = 28
    RULE_deleteStatement = 29
    RULE_mergeStatement = 30
    RULE_mergeCondition = 31
    RULE_updateClause = 32
    RULE_insertClause = 33
    RULE_createStatement = 34
    RULE_createTableStatement = 35
    RULE_columnDefinition = 36
    RULE_dataType = 37
    RULE_precision = 38
    RULE_scale = 39
    RULE_length = 40
    RULE_columnConstraint = 41
    RULE_defaultValue = 42
    RULE_checkCondition = 43
    RULE_createViewStatement = 44
    RULE_createIndexStatement = 45
    RULE_createSequenceStatement = 46
    RULE_startValue = 47
    RULE_incrementValue = 48
    RULE_minValue = 49
    RULE_maxValue = 50
    RULE_alterStatement = 51
    RULE_alterAction = 52
    RULE_constraintName = 53
    RULE_constraintDefinition = 54
    RULE_dropStatement = 55
    RULE_objectName = 56
    RULE_grantStatement = 57
    RULE_privilegeList = 58
    RULE_privilege = 59
    RULE_objectType = 60
    RULE_granteeList = 61
    RULE_grantee = 62
    RULE_revokeStatement = 63
    RULE_commitStatement = 64
    RULE_rollbackStatement = 65
    RULE_beginStatement = 66
    RULE_savepointName = 67
    RULE_setStatement = 68
    RULE_optionName = 69
    RULE_optionValue = 70
    RULE_commentStatement = 71
    RULE_expression = 72
    RULE_primaryExpression = 73
    RULE_literal = 74
    RULE_columnReference = 75
    RULE_tableName = 76
    RULE_columnName = 77
    RULE_parameter = 78
    RULE_operator = 79
    RULE_arithmeticOperator = 80
    RULE_comparisonOperator = 81
    RULE_logicalOperator = 82
    RULE_functionCall = 83
    RULE_functionName = 84
    RULE_argumentList = 85
    RULE_windowFunction = 86
    RULE_windowFunctionName = 87
    RULE_windowSpecification = 88
    RULE_frameSpecification = 89
    RULE_frameStart = 90
    RULE_frameEnd = 91
    RULE_caseExpression = 92
    RULE_whenClause = 93
    RULE_whenExpression = 94
    RULE_thenExpression = 95
    RULE_elseExpression = 96
    RULE_castExpression = 97
    RULE_subquery = 98

    ruleNames =  [ "sqlScript", "sqlStatement", "semicolon", "selectStatement", 
                   "selectList", "selectItem", "alias", "tableExpression", 
                   "tableReference", "tableFunctionName", "viewName", "indexName", 
                   "sequenceName", "joinClause", "joinCondition", "columnList", 
                   "whereClause", "groupByClause", "havingClause", "orderByClause", 
                   "orderByItem", "limitClause", "offsetClause", "fetchClause", 
                   "insertStatement", "valueList", "arguments", "updateStatement", 
                   "setClause", "deleteStatement", "mergeStatement", "mergeCondition", 
                   "updateClause", "insertClause", "createStatement", "createTableStatement", 
                   "columnDefinition", "dataType", "precision", "scale", 
                   "length", "columnConstraint", "defaultValue", "checkCondition", 
                   "createViewStatement", "createIndexStatement", "createSequenceStatement", 
                   "startValue", "incrementValue", "minValue", "maxValue", 
                   "alterStatement", "alterAction", "constraintName", "constraintDefinition", 
                   "dropStatement", "objectName", "grantStatement", "privilegeList", 
                   "privilege", "objectType", "granteeList", "grantee", 
                   "revokeStatement", "commitStatement", "rollbackStatement", 
                   "beginStatement", "savepointName", "setStatement", "optionName", 
                   "optionValue", "commentStatement", "expression", "primaryExpression", 
                   "literal", "columnReference", "tableName", "columnName", 
                   "parameter", "operator", "arithmeticOperator", "comparisonOperator", 
                   "logicalOperator", "functionCall", "functionName", "argumentList", 
                   "windowFunction", "windowFunctionName", "windowSpecification", 
                   "frameSpecification", "frameStart", "frameEnd", "caseExpression", 
                   "whenClause", "whenExpression", "thenExpression", "elseExpression", 
                   "castExpression", "subquery" ]

    EOF = Token.EOF
    IDENTIFIER=1
    NUMBER=2
    STRING=3
    DOUBLE_QUOTED_STRING=4
    HEX_STRING=5
    LPAREN=6
    RPAREN=7
    LBRACKET=8
    RBRACKET=9
    COMMA=10
    SEMICOLON=11
    COLON=12
    EQUALS=13
    PLUS=14
    MINUS=15
    ASTERISK=16
    SLASH=17
    PERCENT=18
    HASH=19
    AT=20
    DOLLAR=21
    DOT=22
    UNDERSCORE=23
    QUESTION=24
    EXCLAMATION=25
    TILDE=26
    CARET=27
    AMPERSAND=28
    PIPE=29
    BACKSLASH=30
    GRAVE=31
    NE=32
    GT=33
    LT=34
    GE=35
    LE=36
    LIKE=37
    NOT_LIKE=38
    IN=39
    NOT_IN=40
    BETWEEN=41
    NOT_BETWEEN=42
    IS=43
    IS_NOT=44
    EXISTS=45
    NOT_EXISTS=46
    AND=47
    OR=48
    NOT=49
    XOR=50
    POWER=51
    WS=52
    COMMENT=53
    LINE_COMMENT=54
    SELECT=55
    FROM=56
    WHERE=57
    GROUP=58
    BY=59
    HAVING=60
    ORDER=61
    ASC=62
    DESC=63
    LIMIT=64
    OFFSET=65
    FETCH=66
    FIRST=67
    NEXT=68
    ROWS=69
    ONLY=70
    INSERT=71
    UPDATE=72
    DELETE=73
    MERGE=74
    VALUES=75
    SET=76
    INTO=77
    CREATE=78
    ALTER=79
    DROP=80
    TRUNCATE=81
    RENAME=82
    GRANT=83
    REVOKE=84
    TABLE=85
    VIEW=86
    INDEX=87
    SEQUENCE=88
    SCHEMA=89
    DATABASE=90
    TABLESPACE=91
    PARTITION=92
    INTEGER=93
    SMALLINT=94
    BIGINT=95
    DECIMAL=96
    REAL=97
    DOUBLE=98
    FLOAT=99
    CHAR=100
    VARCHAR=101
    CLOB=102
    GRAPHIC=103
    VARGRAPHIC=104
    DBCLOB=105
    BLOB=106
    DATE=107
    TIME=108
    TIMESTAMP=109
    XML=110
    PRIMARY=111
    FOREIGN=112
    KEY=113
    UNIQUE=114
    NOT_NULL=115
    NULL=116
    DEFAULT=117
    CHECK=118
    CONSTRAINT=119
    REFERENCES=120
    CASCADE=121
    RESTRICT=122
    SET_NULL=123
    NO_ACTION=124
    COUNT=125
    SUM=126
    AVG=127
    MIN=128
    MAX=129
    COALESCE=130
    NULLIF=131
    CASE=132
    WHEN=133
    THEN=134
    ELSE=135
    END=136
    CAST=137
    CONVERT=138
    SUBSTRING=139
    LENGTH=140
    UPPER=141
    LOWER=142
    TRIM=143
    LTRIM=144
    RTRIM=145
    REPLACE=146
    TRANSLATE=147
    POSITION=148
    LOCATE=149
    JOIN=150
    INNER=151
    LEFT=152
    RIGHT=153
    FULL=154
    OUTER=155
    CROSS=156
    NATURAL=157
    USING=158
    ON=159
    UNION=160
    INTERSECT=161
    EXCEPT=162
    ALL=163
    DISTINCT=164
    ANY=165
    SOME=166
    BEGIN=167
    COMMIT=168
    ROLLBACK=169
    SAVEPOINT=170
    RELEASE=171
    WORK=172
    TRANSACTION=173
    CONNECT=174
    DISCONNECT=175
    RESET=176
    CURRENT_DATE=177
    CURRENT_TIME=178
    CURRENT_TIMESTAMP=179
    CURRENT_USER=180
    USER=181
    SYSTEM_USER=182
    SESSION_USER=183
    WITH=184
    RECURSIVE=185
    LATERAL=186
    RANGE=187
    GROUPS=188
    UNBOUNDED=189
    PRECEDING=190
    FOLLOWING=191
    CURRENT=192
    ROW=193
    OVER=194
    WINDOW=195
    FRAME=196
    EXCLUDE=197
    TIES=198
    RESPECT=199
    IGNORE=200
    NULLS=201
    LAST=202
    KEEP=203
    DENSE_RANK=204
    RANK=205
    ROW_NUMBER=206
    NTILE=207
    LAG=208
    LEAD=209
    FIRST_VALUE=210
    LAST_VALUE=211
    NTH_VALUE=212
    PERCENT_RANK=213
    CUME_DIST=214
    PERCENTILE_CONT=215
    PERCENTILE_DISC=216
    AS=217
    MATCHED=218
    START=219
    INCREMENT=220
    MINVALUE=221
    MAXVALUE=222
    ADD=223
    COLUMN=224
    MODIFY=225
    TO=226
    PUBLIC=227
    EQ=228

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SqlScriptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(db2_parser.EOF, 0)

        def sqlStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.SqlStatementContext)
            else:
                return self.getTypedRuleContext(db2_parser.SqlStatementContext,i)


        def getRuleIndex(self):
            return db2_parser.RULE_sqlScript

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlScript" ):
                listener.enterSqlScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlScript" ):
                listener.exitSqlScript(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSqlScript" ):
                return visitor.visitSqlScript(self)
            else:
                return visitor.visitChildren(self)




    def sqlScript(self):

        localctx = db2_parser.SqlScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sqlScript)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 45035996273707008) != 0) or ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 13231) != 0) or ((((_la - 167)) & ~0x3f) == 0 and ((1 << (_la - 167)) & 7) != 0):
                self.state = 198
                self.sqlStatement()
                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 204
            self.match(db2_parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqlStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectStatement(self):
            return self.getTypedRuleContext(db2_parser.SelectStatementContext,0)


        def insertStatement(self):
            return self.getTypedRuleContext(db2_parser.InsertStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(db2_parser.UpdateStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(db2_parser.DeleteStatementContext,0)


        def mergeStatement(self):
            return self.getTypedRuleContext(db2_parser.MergeStatementContext,0)


        def createStatement(self):
            return self.getTypedRuleContext(db2_parser.CreateStatementContext,0)


        def alterStatement(self):
            return self.getTypedRuleContext(db2_parser.AlterStatementContext,0)


        def dropStatement(self):
            return self.getTypedRuleContext(db2_parser.DropStatementContext,0)


        def grantStatement(self):
            return self.getTypedRuleContext(db2_parser.GrantStatementContext,0)


        def revokeStatement(self):
            return self.getTypedRuleContext(db2_parser.RevokeStatementContext,0)


        def commitStatement(self):
            return self.getTypedRuleContext(db2_parser.CommitStatementContext,0)


        def rollbackStatement(self):
            return self.getTypedRuleContext(db2_parser.RollbackStatementContext,0)


        def beginStatement(self):
            return self.getTypedRuleContext(db2_parser.BeginStatementContext,0)


        def setStatement(self):
            return self.getTypedRuleContext(db2_parser.SetStatementContext,0)


        def commentStatement(self):
            return self.getTypedRuleContext(db2_parser.CommentStatementContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(db2_parser.SemicolonContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_sqlStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlStatement" ):
                listener.enterSqlStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlStatement" ):
                listener.exitSqlStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSqlStatement" ):
                return visitor.visitSqlStatement(self)
            else:
                return visitor.visitChildren(self)




    def sqlStatement(self):

        localctx = db2_parser.SqlStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sqlStatement)
        try:
            self.state = 222
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [55]:
                self.enterOuterAlt(localctx, 1)
                self.state = 206
                self.selectStatement()
                pass
            elif token in [71]:
                self.enterOuterAlt(localctx, 2)
                self.state = 207
                self.insertStatement()
                pass
            elif token in [72]:
                self.enterOuterAlt(localctx, 3)
                self.state = 208
                self.updateStatement()
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 4)
                self.state = 209
                self.deleteStatement()
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 5)
                self.state = 210
                self.mergeStatement()
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 6)
                self.state = 211
                self.createStatement()
                pass
            elif token in [79]:
                self.enterOuterAlt(localctx, 7)
                self.state = 212
                self.alterStatement()
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 8)
                self.state = 213
                self.dropStatement()
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 9)
                self.state = 214
                self.grantStatement()
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 10)
                self.state = 215
                self.revokeStatement()
                pass
            elif token in [168]:
                self.enterOuterAlt(localctx, 11)
                self.state = 216
                self.commitStatement()
                pass
            elif token in [169]:
                self.enterOuterAlt(localctx, 12)
                self.state = 217
                self.rollbackStatement()
                pass
            elif token in [167]:
                self.enterOuterAlt(localctx, 13)
                self.state = 218
                self.beginStatement()
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 14)
                self.state = 219
                self.setStatement()
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 15)
                self.state = 220
                self.commentStatement()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 16)
                self.state = 221
                self.semicolon()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SemicolonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(db2_parser.SEMICOLON, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_semicolon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSemicolon" ):
                listener.enterSemicolon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSemicolon" ):
                listener.exitSemicolon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSemicolon" ):
                return visitor.visitSemicolon(self)
            else:
                return visitor.visitChildren(self)




    def semicolon(self):

        localctx = db2_parser.SemicolonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_semicolon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(db2_parser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(db2_parser.SELECT, 0)

        def selectList(self):
            return self.getTypedRuleContext(db2_parser.SelectListContext,0)


        def FROM(self):
            return self.getToken(db2_parser.FROM, 0)

        def tableExpression(self):
            return self.getTypedRuleContext(db2_parser.TableExpressionContext,0)


        def WHERE(self):
            return self.getToken(db2_parser.WHERE, 0)

        def whereClause(self):
            return self.getTypedRuleContext(db2_parser.WhereClauseContext,0)


        def GROUP(self):
            return self.getToken(db2_parser.GROUP, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.BY)
            else:
                return self.getToken(db2_parser.BY, i)

        def groupByClause(self):
            return self.getTypedRuleContext(db2_parser.GroupByClauseContext,0)


        def HAVING(self):
            return self.getToken(db2_parser.HAVING, 0)

        def havingClause(self):
            return self.getTypedRuleContext(db2_parser.HavingClauseContext,0)


        def ORDER(self):
            return self.getToken(db2_parser.ORDER, 0)

        def orderByClause(self):
            return self.getTypedRuleContext(db2_parser.OrderByClauseContext,0)


        def LIMIT(self):
            return self.getToken(db2_parser.LIMIT, 0)

        def limitClause(self):
            return self.getTypedRuleContext(db2_parser.LimitClauseContext,0)


        def OFFSET(self):
            return self.getToken(db2_parser.OFFSET, 0)

        def offsetClause(self):
            return self.getTypedRuleContext(db2_parser.OffsetClauseContext,0)


        def FETCH(self):
            return self.getToken(db2_parser.FETCH, 0)

        def fetchClause(self):
            return self.getTypedRuleContext(db2_parser.FetchClauseContext,0)


        def DISTINCT(self):
            return self.getToken(db2_parser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(db2_parser.ALL, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_selectStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStatement" ):
                listener.enterSelectStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStatement" ):
                listener.exitSelectStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStatement" ):
                return visitor.visitSelectStatement(self)
            else:
                return visitor.visitChildren(self)




    def selectStatement(self):

        localctx = db2_parser.SelectStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_selectStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(db2_parser.SELECT)
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==163 or _la==164:
                self.state = 227
                _la = self._input.LA(1)
                if not(_la==163 or _la==164):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 230
            self.selectList()
            self.state = 231
            self.match(db2_parser.FROM)
            self.state = 232
            self.tableExpression(0)
            self.state = 235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 233
                self.match(db2_parser.WHERE)
                self.state = 234
                self.whereClause()


            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 237
                self.match(db2_parser.GROUP)
                self.state = 238
                self.match(db2_parser.BY)
                self.state = 239
                self.groupByClause()


            self.state = 244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 242
                self.match(db2_parser.HAVING)
                self.state = 243
                self.havingClause()


            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 246
                self.match(db2_parser.ORDER)
                self.state = 247
                self.match(db2_parser.BY)
                self.state = 248
                self.orderByClause()


            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 251
                self.match(db2_parser.LIMIT)
                self.state = 252
                self.limitClause()


            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 255
                self.match(db2_parser.OFFSET)
                self.state = 256
                self.offsetClause()


            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 259
                self.match(db2_parser.FETCH)
                self.state = 260
                self.fetchClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.SelectItemContext)
            else:
                return self.getTypedRuleContext(db2_parser.SelectItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def ASTERISK(self):
            return self.getToken(db2_parser.ASTERISK, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_selectList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectList" ):
                listener.enterSelectList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectList" ):
                listener.exitSelectList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectList" ):
                return visitor.visitSelectList(self)
            else:
                return visitor.visitChildren(self)




    def selectList(self):

        localctx = db2_parser.SelectListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_selectList)
        self._la = 0 # Token type
        try:
            self.state = 272
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 2, 3, 4, 5, 6, 24, 116, 125, 126, 127, 128, 129, 130, 131, 132, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 177, 178, 179, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216]:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.selectItem()
                self.state = 268
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==10:
                    self.state = 264
                    self.match(db2_parser.COMMA)
                    self.state = 265
                    self.selectItem()
                    self.state = 270
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 271
                self.match(db2_parser.ASTERISK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def alias(self):
            return self.getTypedRuleContext(db2_parser.AliasContext,0)


        def AS(self):
            return self.getToken(db2_parser.AS, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def DOT(self):
            return self.getToken(db2_parser.DOT, 0)

        def ASTERISK(self):
            return self.getToken(db2_parser.ASTERISK, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_selectItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectItem" ):
                listener.enterSelectItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectItem" ):
                listener.exitSelectItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectItem" ):
                return visitor.visitSelectItem(self)
            else:
                return visitor.visitChildren(self)




    def selectItem(self):

        localctx = db2_parser.SelectItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_selectItem)
        self._la = 0 # Token type
        try:
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 274
                self.expression(0)
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1 or _la==3 or _la==217:
                    self.state = 276
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 275
                        self.match(db2_parser.AS)


                    self.state = 278
                    self.alias()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 281
                self.tableName()
                self.state = 282
                self.match(db2_parser.DOT)
                self.state = 283
                self.match(db2_parser.ASTERISK)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def STRING(self):
            return self.getToken(db2_parser.STRING, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias" ):
                listener.enterAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias" ):
                listener.exitAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias" ):
                return visitor.visitAlias(self)
            else:
                return visitor.visitChildren(self)




    def alias(self):

        localctx = db2_parser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_alias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            _la = self._input.LA(1)
            if not(_la==1 or _la==3):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableReference(self):
            return self.getTypedRuleContext(db2_parser.TableReferenceContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def tableExpression(self):
            return self.getTypedRuleContext(db2_parser.TableExpressionContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def joinClause(self):
            return self.getTypedRuleContext(db2_parser.JoinClauseContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_tableExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableExpression" ):
                listener.enterTableExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableExpression" ):
                listener.exitTableExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableExpression" ):
                return visitor.visitTableExpression(self)
            else:
                return visitor.visitChildren(self)



    def tableExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = db2_parser.TableExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_tableExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 290
                self.tableReference()
                pass

            elif la_ == 2:
                self.state = 291
                self.match(db2_parser.LPAREN)
                self.state = 292
                self.tableExpression(0)
                self.state = 293
                self.match(db2_parser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 301
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = db2_parser.TableExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tableExpression)
                    self.state = 297
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 298
                    self.joinClause() 
                self.state = 303
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def alias(self):
            return self.getTypedRuleContext(db2_parser.AliasContext,0)


        def AS(self):
            return self.getToken(db2_parser.AS, 0)

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def selectStatement(self):
            return self.getTypedRuleContext(db2_parser.SelectStatementContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def tableFunctionName(self):
            return self.getTypedRuleContext(db2_parser.TableFunctionNameContext,0)


        def arguments(self):
            return self.getTypedRuleContext(db2_parser.ArgumentsContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_tableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableReference" ):
                listener.enterTableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableReference" ):
                listener.exitTableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableReference" ):
                return visitor.visitTableReference(self)
            else:
                return visitor.visitChildren(self)




    def tableReference(self):

        localctx = db2_parser.TableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_tableReference)
        self._la = 0 # Token type
        try:
            self.state = 332
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 304
                self.tableName()
                self.state = 309
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 306
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 305
                        self.match(db2_parser.AS)


                    self.state = 308
                    self.alias()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 311
                self.match(db2_parser.LPAREN)
                self.state = 312
                self.selectStatement()
                self.state = 313
                self.match(db2_parser.RPAREN)
                self.state = 318
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                if la_ == 1:
                    self.state = 315
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 314
                        self.match(db2_parser.AS)


                    self.state = 317
                    self.alias()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 320
                self.tableFunctionName()
                self.state = 321
                self.match(db2_parser.LPAREN)
                self.state = 323
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 16777342) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & -2305842992039985663) != 0) or ((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & 8191) != 0):
                    self.state = 322
                    self.arguments()


                self.state = 325
                self.match(db2_parser.RPAREN)
                self.state = 330
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 327
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 326
                        self.match(db2_parser.AS)


                    self.state = 329
                    self.alias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableFunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_tableFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableFunctionName" ):
                listener.enterTableFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableFunctionName" ):
                listener.exitTableFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFunctionName" ):
                return visitor.visitTableFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def tableFunctionName(self):

        localctx = db2_parser.TableFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_tableFunctionName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_viewName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewName" ):
                listener.enterViewName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewName" ):
                listener.exitViewName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewName" ):
                return visitor.visitViewName(self)
            else:
                return visitor.visitChildren(self)




    def viewName(self):

        localctx = db2_parser.ViewNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_viewName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_indexName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexName" ):
                listener.enterIndexName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexName" ):
                listener.exitIndexName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexName" ):
                return visitor.visitIndexName(self)
            else:
                return visitor.visitChildren(self)




    def indexName(self):

        localctx = db2_parser.IndexNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_indexName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_sequenceName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceName" ):
                listener.enterSequenceName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceName" ):
                listener.exitSequenceName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequenceName" ):
                return visitor.visitSequenceName(self)
            else:
                return visitor.visitChildren(self)




    def sequenceName(self):

        localctx = db2_parser.SequenceNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_sequenceName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOIN(self):
            return self.getToken(db2_parser.JOIN, 0)

        def tableReference(self):
            return self.getTypedRuleContext(db2_parser.TableReferenceContext,0)


        def INNER(self):
            return self.getToken(db2_parser.INNER, 0)

        def CROSS(self):
            return self.getToken(db2_parser.CROSS, 0)

        def NATURAL(self):
            return self.getToken(db2_parser.NATURAL, 0)

        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def joinCondition(self):
            return self.getTypedRuleContext(db2_parser.JoinConditionContext,0)


        def USING(self):
            return self.getToken(db2_parser.USING, 0)

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnList(self):
            return self.getTypedRuleContext(db2_parser.ColumnListContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def LEFT(self):
            return self.getToken(db2_parser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(db2_parser.RIGHT, 0)

        def FULL(self):
            return self.getToken(db2_parser.FULL, 0)

        def OUTER(self):
            return self.getToken(db2_parser.OUTER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_joinClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinClause" ):
                listener.enterJoinClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinClause" ):
                listener.exitJoinClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinClause" ):
                return visitor.visitJoinClause(self)
            else:
                return visitor.visitChildren(self)




    def joinClause(self):

        localctx = db2_parser.JoinClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_joinClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [151]:
                self.state = 342
                self.match(db2_parser.INNER)
                pass
            elif token in [152, 153, 154]:
                self.state = 343
                _la = self._input.LA(1)
                if not(((((_la - 152)) & ~0x3f) == 0 and ((1 << (_la - 152)) & 7) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 345
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==155:
                    self.state = 344
                    self.match(db2_parser.OUTER)


                pass
            elif token in [156]:
                self.state = 347
                self.match(db2_parser.CROSS)
                pass
            elif token in [157]:
                self.state = 348
                self.match(db2_parser.NATURAL)
                pass
            elif token in [150]:
                pass
            else:
                pass
            self.state = 351
            self.match(db2_parser.JOIN)
            self.state = 352
            self.tableReference()
            self.state = 360
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 353
                self.match(db2_parser.ON)
                self.state = 354
                self.joinCondition()

            elif la_ == 2:
                self.state = 355
                self.match(db2_parser.USING)
                self.state = 356
                self.match(db2_parser.LPAREN)
                self.state = 357
                self.columnList()
                self.state = 358
                self.match(db2_parser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_joinCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinCondition" ):
                listener.enterJoinCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinCondition" ):
                listener.exitJoinCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinCondition" ):
                return visitor.visitJoinCondition(self)
            else:
                return visitor.visitChildren(self)




    def joinCondition(self):

        localctx = db2_parser.JoinConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_joinCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ColumnNameContext)
            else:
                return self.getTypedRuleContext(db2_parser.ColumnNameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_columnList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnList" ):
                listener.enterColumnList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnList" ):
                listener.exitColumnList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnList" ):
                return visitor.visitColumnList(self)
            else:
                return visitor.visitChildren(self)




    def columnList(self):

        localctx = db2_parser.ColumnListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_columnList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self.columnName()
            self.state = 369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 365
                self.match(db2_parser.COMMA)
                self.state = 366
                self.columnName()
                self.state = 371
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhereClause" ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhereClause" ):
                listener.exitWhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhereClause" ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = db2_parser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_groupByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupByClause" ):
                listener.enterGroupByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupByClause" ):
                listener.exitGroupByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupByClause" ):
                return visitor.visitGroupByClause(self)
            else:
                return visitor.visitChildren(self)




    def groupByClause(self):

        localctx = db2_parser.GroupByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_groupByClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            self.expression(0)
            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 375
                self.match(db2_parser.COMMA)
                self.state = 376
                self.expression(0)
                self.state = 381
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHavingClause" ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHavingClause" ):
                listener.exitHavingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHavingClause" ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = db2_parser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderByItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.OrderByItemContext)
            else:
                return self.getTypedRuleContext(db2_parser.OrderByItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_orderByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByClause" ):
                listener.enterOrderByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByClause" ):
                listener.exitOrderByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByClause" ):
                return visitor.visitOrderByClause(self)
            else:
                return visitor.visitChildren(self)




    def orderByClause(self):

        localctx = db2_parser.OrderByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_orderByClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 384
            self.orderByItem()
            self.state = 389
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 385
                self.match(db2_parser.COMMA)
                self.state = 386
                self.orderByItem()
                self.state = 391
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderByItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def ASC(self):
            return self.getToken(db2_parser.ASC, 0)

        def DESC(self):
            return self.getToken(db2_parser.DESC, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_orderByItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByItem" ):
                listener.enterOrderByItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByItem" ):
                listener.exitOrderByItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByItem" ):
                return visitor.visitOrderByItem(self)
            else:
                return visitor.visitChildren(self)




    def orderByItem(self):

        localctx = db2_parser.OrderByItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_orderByItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 392
            self.expression(0)
            self.state = 394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62 or _la==63:
                self.state = 393
                _la = self._input.LA(1)
                if not(_la==62 or _la==63):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitClause" ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitClause" ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitClause" ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = db2_parser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_limitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_offsetClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffsetClause" ):
                listener.enterOffsetClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffsetClause" ):
                listener.exitOffsetClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOffsetClause" ):
                return visitor.visitOffsetClause(self)
            else:
                return visitor.visitChildren(self)




    def offsetClause(self):

        localctx = db2_parser.OffsetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_offsetClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FetchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST(self):
            return self.getToken(db2_parser.FIRST, 0)

        def NEXT(self):
            return self.getToken(db2_parser.NEXT, 0)

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def ONLY(self):
            return self.getToken(db2_parser.ONLY, 0)

        def ROWS(self):
            return self.getToken(db2_parser.ROWS, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_fetchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFetchClause" ):
                listener.enterFetchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFetchClause" ):
                listener.exitFetchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFetchClause" ):
                return visitor.visitFetchClause(self)
            else:
                return visitor.visitChildren(self)




    def fetchClause(self):

        localctx = db2_parser.FetchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_fetchClause)
        self._la = 0 # Token type
        try:
            self.state = 407
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [67]:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.match(db2_parser.FIRST)
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 2)
                self.state = 401
                self.match(db2_parser.NEXT)
                self.state = 402
                self.match(db2_parser.NUMBER)
                self.state = 404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==69:
                    self.state = 403
                    self.match(db2_parser.ROWS)


                self.state = 406
                self.match(db2_parser.ONLY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(db2_parser.INSERT, 0)

        def INTO(self):
            return self.getToken(db2_parser.INTO, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def VALUES(self):
            return self.getToken(db2_parser.VALUES, 0)

        def valueList(self):
            return self.getTypedRuleContext(db2_parser.ValueListContext,0)


        def selectStatement(self):
            return self.getTypedRuleContext(db2_parser.SelectStatementContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnList(self):
            return self.getTypedRuleContext(db2_parser.ColumnListContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_insertStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertStatement" ):
                listener.enterInsertStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertStatement" ):
                listener.exitInsertStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertStatement" ):
                return visitor.visitInsertStatement(self)
            else:
                return visitor.visitChildren(self)




    def insertStatement(self):

        localctx = db2_parser.InsertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_insertStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            self.match(db2_parser.INSERT)
            self.state = 410
            self.match(db2_parser.INTO)
            self.state = 411
            self.tableName()
            self.state = 416
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 412
                self.match(db2_parser.LPAREN)
                self.state = 413
                self.columnList()
                self.state = 414
                self.match(db2_parser.RPAREN)


            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [75]:
                self.state = 418
                self.match(db2_parser.VALUES)
                self.state = 419
                self.valueList()
                pass
            elif token in [55]:
                self.state = 420
                self.selectStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_valueList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueList" ):
                listener.enterValueList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueList" ):
                listener.exitValueList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueList" ):
                return visitor.visitValueList(self)
            else:
                return visitor.visitChildren(self)




    def valueList(self):

        localctx = db2_parser.ValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_valueList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            self.match(db2_parser.LPAREN)
            self.state = 424
            self.expression(0)
            self.state = 429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 425
                self.match(db2_parser.COMMA)
                self.state = 426
                self.expression(0)
                self.state = 431
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 432
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArguments" ):
                return visitor.visitArguments(self)
            else:
                return visitor.visitChildren(self)




    def arguments(self):

        localctx = db2_parser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.expression(0)
            self.state = 439
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 435
                self.match(db2_parser.COMMA)
                self.state = 436
                self.expression(0)
                self.state = 441
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(db2_parser.UPDATE, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def SET(self):
            return self.getToken(db2_parser.SET, 0)

        def setClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.SetClauseContext)
            else:
                return self.getTypedRuleContext(db2_parser.SetClauseContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def WHERE(self):
            return self.getToken(db2_parser.WHERE, 0)

        def whereClause(self):
            return self.getTypedRuleContext(db2_parser.WhereClauseContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_updateStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateStatement" ):
                listener.enterUpdateStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateStatement" ):
                listener.exitUpdateStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateStatement" ):
                return visitor.visitUpdateStatement(self)
            else:
                return visitor.visitChildren(self)




    def updateStatement(self):

        localctx = db2_parser.UpdateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_updateStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.match(db2_parser.UPDATE)
            self.state = 443
            self.tableName()
            self.state = 444
            self.match(db2_parser.SET)
            self.state = 445
            self.setClause()
            self.state = 450
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 446
                self.match(db2_parser.COMMA)
                self.state = 447
                self.setClause()
                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 453
                self.match(db2_parser.WHERE)
                self.state = 454
                self.whereClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self):
            return self.getTypedRuleContext(db2_parser.ColumnNameContext,0)


        def EQUALS(self):
            return self.getToken(db2_parser.EQUALS, 0)

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_setClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetClause" ):
                listener.enterSetClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetClause" ):
                listener.exitSetClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetClause" ):
                return visitor.visitSetClause(self)
            else:
                return visitor.visitChildren(self)




    def setClause(self):

        localctx = db2_parser.SetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_setClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.columnName()
            self.state = 458
            self.match(db2_parser.EQUALS)
            self.state = 459
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(db2_parser.DELETE, 0)

        def FROM(self):
            return self.getToken(db2_parser.FROM, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def WHERE(self):
            return self.getToken(db2_parser.WHERE, 0)

        def whereClause(self):
            return self.getTypedRuleContext(db2_parser.WhereClauseContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_deleteStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteStatement" ):
                listener.enterDeleteStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteStatement" ):
                listener.exitDeleteStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteStatement" ):
                return visitor.visitDeleteStatement(self)
            else:
                return visitor.visitChildren(self)




    def deleteStatement(self):

        localctx = db2_parser.DeleteStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_deleteStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            self.match(db2_parser.DELETE)
            self.state = 462
            self.match(db2_parser.FROM)
            self.state = 463
            self.tableName()
            self.state = 466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 464
                self.match(db2_parser.WHERE)
                self.state = 465
                self.whereClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MergeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MERGE(self):
            return self.getToken(db2_parser.MERGE, 0)

        def INTO(self):
            return self.getToken(db2_parser.INTO, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def USING(self):
            return self.getToken(db2_parser.USING, 0)

        def tableReference(self):
            return self.getTypedRuleContext(db2_parser.TableReferenceContext,0)


        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def mergeCondition(self):
            return self.getTypedRuleContext(db2_parser.MergeConditionContext,0)


        def alias(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.AliasContext)
            else:
                return self.getTypedRuleContext(db2_parser.AliasContext,i)


        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.WHEN)
            else:
                return self.getToken(db2_parser.WHEN, i)

        def MATCHED(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.MATCHED)
            else:
                return self.getToken(db2_parser.MATCHED, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.THEN)
            else:
                return self.getToken(db2_parser.THEN, i)

        def updateClause(self):
            return self.getTypedRuleContext(db2_parser.UpdateClauseContext,0)


        def NOT(self):
            return self.getToken(db2_parser.NOT, 0)

        def insertClause(self):
            return self.getTypedRuleContext(db2_parser.InsertClauseContext,0)


        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.AS)
            else:
                return self.getToken(db2_parser.AS, i)

        def getRuleIndex(self):
            return db2_parser.RULE_mergeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeStatement" ):
                listener.enterMergeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeStatement" ):
                listener.exitMergeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeStatement" ):
                return visitor.visitMergeStatement(self)
            else:
                return visitor.visitChildren(self)




    def mergeStatement(self):

        localctx = db2_parser.MergeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_mergeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self.match(db2_parser.MERGE)
            self.state = 469
            self.match(db2_parser.INTO)
            self.state = 470
            self.tableName()
            self.state = 475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==3 or _la==217:
                self.state = 472
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==217:
                    self.state = 471
                    self.match(db2_parser.AS)


                self.state = 474
                self.alias()


            self.state = 477
            self.match(db2_parser.USING)
            self.state = 478
            self.tableReference()
            self.state = 483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==3 or _la==217:
                self.state = 480
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==217:
                    self.state = 479
                    self.match(db2_parser.AS)


                self.state = 482
                self.alias()


            self.state = 485
            self.match(db2_parser.ON)
            self.state = 486
            self.mergeCondition()
            self.state = 491
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.state = 487
                self.match(db2_parser.WHEN)
                self.state = 488
                self.match(db2_parser.MATCHED)
                self.state = 489
                self.match(db2_parser.THEN)
                self.state = 490
                self.updateClause()


            self.state = 498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==133:
                self.state = 493
                self.match(db2_parser.WHEN)
                self.state = 494
                self.match(db2_parser.NOT)
                self.state = 495
                self.match(db2_parser.MATCHED)
                self.state = 496
                self.match(db2_parser.THEN)
                self.state = 497
                self.insertClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MergeConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_mergeCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeCondition" ):
                listener.enterMergeCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeCondition" ):
                listener.exitMergeCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeCondition" ):
                return visitor.visitMergeCondition(self)
            else:
                return visitor.visitChildren(self)




    def mergeCondition(self):

        localctx = db2_parser.MergeConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_mergeCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 500
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(db2_parser.UPDATE, 0)

        def SET(self):
            return self.getToken(db2_parser.SET, 0)

        def setClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.SetClauseContext)
            else:
                return self.getTypedRuleContext(db2_parser.SetClauseContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_updateClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateClause" ):
                listener.enterUpdateClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateClause" ):
                listener.exitUpdateClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateClause" ):
                return visitor.visitUpdateClause(self)
            else:
                return visitor.visitChildren(self)




    def updateClause(self):

        localctx = db2_parser.UpdateClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_updateClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self.match(db2_parser.UPDATE)
            self.state = 503
            self.match(db2_parser.SET)
            self.state = 504
            self.setClause()
            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 505
                self.match(db2_parser.COMMA)
                self.state = 506
                self.setClause()
                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(db2_parser.INSERT, 0)

        def VALUES(self):
            return self.getToken(db2_parser.VALUES, 0)

        def valueList(self):
            return self.getTypedRuleContext(db2_parser.ValueListContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnList(self):
            return self.getTypedRuleContext(db2_parser.ColumnListContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_insertClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertClause" ):
                listener.enterInsertClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertClause" ):
                listener.exitInsertClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertClause" ):
                return visitor.visitInsertClause(self)
            else:
                return visitor.visitChildren(self)




    def insertClause(self):

        localctx = db2_parser.InsertClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_insertClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(db2_parser.INSERT)
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 513
                self.match(db2_parser.LPAREN)
                self.state = 514
                self.columnList()
                self.state = 515
                self.match(db2_parser.RPAREN)


            self.state = 519
            self.match(db2_parser.VALUES)
            self.state = 520
            self.valueList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createTableStatement(self):
            return self.getTypedRuleContext(db2_parser.CreateTableStatementContext,0)


        def createViewStatement(self):
            return self.getTypedRuleContext(db2_parser.CreateViewStatementContext,0)


        def createIndexStatement(self):
            return self.getTypedRuleContext(db2_parser.CreateIndexStatementContext,0)


        def createSequenceStatement(self):
            return self.getTypedRuleContext(db2_parser.CreateSequenceStatementContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_createStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateStatement" ):
                listener.enterCreateStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateStatement" ):
                listener.exitCreateStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateStatement" ):
                return visitor.visitCreateStatement(self)
            else:
                return visitor.visitChildren(self)




    def createStatement(self):

        localctx = db2_parser.CreateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_createStatement)
        try:
            self.state = 526
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 522
                self.createTableStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 523
                self.createViewStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 524
                self.createIndexStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 525
                self.createSequenceStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(db2_parser.CREATE, 0)

        def TABLE(self):
            return self.getToken(db2_parser.TABLE, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ColumnDefinitionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ColumnDefinitionContext,i)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_createTableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTableStatement" ):
                listener.enterCreateTableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTableStatement" ):
                listener.exitCreateTableStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableStatement" ):
                return visitor.visitCreateTableStatement(self)
            else:
                return visitor.visitChildren(self)




    def createTableStatement(self):

        localctx = db2_parser.CreateTableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_createTableStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.match(db2_parser.CREATE)
            self.state = 529
            self.match(db2_parser.TABLE)
            self.state = 530
            self.tableName()
            self.state = 531
            self.match(db2_parser.LPAREN)
            self.state = 532
            self.columnDefinition()
            self.state = 537
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 533
                self.match(db2_parser.COMMA)
                self.state = 534
                self.columnDefinition()
                self.state = 539
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 540
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self):
            return self.getTypedRuleContext(db2_parser.ColumnNameContext,0)


        def dataType(self):
            return self.getTypedRuleContext(db2_parser.DataTypeContext,0)


        def columnConstraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ColumnConstraintContext)
            else:
                return self.getTypedRuleContext(db2_parser.ColumnConstraintContext,i)


        def getRuleIndex(self):
            return db2_parser.RULE_columnDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnDefinition" ):
                listener.enterColumnDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnDefinition" ):
                listener.exitColumnDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnDefinition" ):
                return visitor.visitColumnDefinition(self)
            else:
                return visitor.visitChildren(self)




    def columnDefinition(self):

        localctx = db2_parser.ColumnDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_columnDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 542
            self.columnName()
            self.state = 543
            self.dataType()
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & 729) != 0):
                self.state = 544
                self.columnConstraint()
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(db2_parser.INTEGER, 0)

        def SMALLINT(self):
            return self.getToken(db2_parser.SMALLINT, 0)

        def BIGINT(self):
            return self.getToken(db2_parser.BIGINT, 0)

        def DECIMAL(self):
            return self.getToken(db2_parser.DECIMAL, 0)

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def precision(self):
            return self.getTypedRuleContext(db2_parser.PrecisionContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(db2_parser.COMMA, 0)

        def scale(self):
            return self.getTypedRuleContext(db2_parser.ScaleContext,0)


        def REAL(self):
            return self.getToken(db2_parser.REAL, 0)

        def DOUBLE(self):
            return self.getToken(db2_parser.DOUBLE, 0)

        def FLOAT(self):
            return self.getToken(db2_parser.FLOAT, 0)

        def CHAR(self):
            return self.getToken(db2_parser.CHAR, 0)

        def length(self):
            return self.getTypedRuleContext(db2_parser.LengthContext,0)


        def VARCHAR(self):
            return self.getToken(db2_parser.VARCHAR, 0)

        def DATE(self):
            return self.getToken(db2_parser.DATE, 0)

        def TIME(self):
            return self.getToken(db2_parser.TIME, 0)

        def TIMESTAMP(self):
            return self.getToken(db2_parser.TIMESTAMP, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_dataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataType" ):
                listener.enterDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataType" ):
                listener.exitDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataType" ):
                return visitor.visitDataType(self)
            else:
                return visitor.visitChildren(self)




    def dataType(self):

        localctx = db2_parser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.state = 584
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [93]:
                self.enterOuterAlt(localctx, 1)
                self.state = 550
                self.match(db2_parser.INTEGER)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 2)
                self.state = 551
                self.match(db2_parser.SMALLINT)
                pass
            elif token in [95]:
                self.enterOuterAlt(localctx, 3)
                self.state = 552
                self.match(db2_parser.BIGINT)
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 4)
                self.state = 553
                self.match(db2_parser.DECIMAL)
                self.state = 562
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 554
                    self.match(db2_parser.LPAREN)
                    self.state = 555
                    self.precision()
                    self.state = 558
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==10:
                        self.state = 556
                        self.match(db2_parser.COMMA)
                        self.state = 557
                        self.scale()


                    self.state = 560
                    self.match(db2_parser.RPAREN)


                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 5)
                self.state = 564
                self.match(db2_parser.REAL)
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 6)
                self.state = 565
                self.match(db2_parser.DOUBLE)
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 7)
                self.state = 566
                self.match(db2_parser.FLOAT)
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 8)
                self.state = 567
                self.match(db2_parser.CHAR)
                self.state = 572
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 568
                    self.match(db2_parser.LPAREN)
                    self.state = 569
                    self.length()
                    self.state = 570
                    self.match(db2_parser.RPAREN)


                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 9)
                self.state = 574
                self.match(db2_parser.VARCHAR)
                self.state = 579
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 575
                    self.match(db2_parser.LPAREN)
                    self.state = 576
                    self.length()
                    self.state = 577
                    self.match(db2_parser.RPAREN)


                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 10)
                self.state = 581
                self.match(db2_parser.DATE)
                pass
            elif token in [108]:
                self.enterOuterAlt(localctx, 11)
                self.state = 582
                self.match(db2_parser.TIME)
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 12)
                self.state = 583
                self.match(db2_parser.TIMESTAMP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_precision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrecision" ):
                listener.enterPrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrecision" ):
                listener.exitPrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrecision" ):
                return visitor.visitPrecision(self)
            else:
                return visitor.visitChildren(self)




    def precision(self):

        localctx = db2_parser.PrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_precision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 586
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScaleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_scale

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScale" ):
                listener.enterScale(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScale" ):
                listener.exitScale(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScale" ):
                return visitor.visitScale(self)
            else:
                return visitor.visitChildren(self)




    def scale(self):

        localctx = db2_parser.ScaleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_scale)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 588
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_length

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLength" ):
                listener.enterLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLength" ):
                listener.exitLength(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLength" ):
                return visitor.visitLength(self)
            else:
                return visitor.visitChildren(self)




    def length(self):

        localctx = db2_parser.LengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_length)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 590
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT_NULL(self):
            return self.getToken(db2_parser.NOT_NULL, 0)

        def DEFAULT(self):
            return self.getToken(db2_parser.DEFAULT, 0)

        def defaultValue(self):
            return self.getTypedRuleContext(db2_parser.DefaultValueContext,0)


        def PRIMARY(self):
            return self.getToken(db2_parser.PRIMARY, 0)

        def KEY(self):
            return self.getToken(db2_parser.KEY, 0)

        def UNIQUE(self):
            return self.getToken(db2_parser.UNIQUE, 0)

        def CHECK(self):
            return self.getToken(db2_parser.CHECK, 0)

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def checkCondition(self):
            return self.getTypedRuleContext(db2_parser.CheckConditionContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def REFERENCES(self):
            return self.getToken(db2_parser.REFERENCES, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def columnName(self):
            return self.getTypedRuleContext(db2_parser.ColumnNameContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_columnConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnConstraint" ):
                listener.enterColumnConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnConstraint" ):
                listener.exitColumnConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnConstraint" ):
                return visitor.visitColumnConstraint(self)
            else:
                return visitor.visitChildren(self)




    def columnConstraint(self):

        localctx = db2_parser.ColumnConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_columnConstraint)
        self._la = 0 # Token type
        try:
            self.state = 611
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.enterOuterAlt(localctx, 1)
                self.state = 592
                self.match(db2_parser.NOT_NULL)
                pass
            elif token in [117]:
                self.enterOuterAlt(localctx, 2)
                self.state = 593
                self.match(db2_parser.DEFAULT)
                self.state = 594
                self.defaultValue()
                pass
            elif token in [111]:
                self.enterOuterAlt(localctx, 3)
                self.state = 595
                self.match(db2_parser.PRIMARY)
                self.state = 596
                self.match(db2_parser.KEY)
                pass
            elif token in [114]:
                self.enterOuterAlt(localctx, 4)
                self.state = 597
                self.match(db2_parser.UNIQUE)
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 5)
                self.state = 598
                self.match(db2_parser.CHECK)
                self.state = 599
                self.match(db2_parser.LPAREN)
                self.state = 600
                self.checkCondition()
                self.state = 601
                self.match(db2_parser.RPAREN)
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 6)
                self.state = 603
                self.match(db2_parser.REFERENCES)
                self.state = 604
                self.tableName()
                self.state = 609
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 605
                    self.match(db2_parser.LPAREN)
                    self.state = 606
                    self.columnName()
                    self.state = 607
                    self.match(db2_parser.RPAREN)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_defaultValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultValue" ):
                listener.enterDefaultValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultValue" ):
                listener.exitDefaultValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultValue" ):
                return visitor.visitDefaultValue(self)
            else:
                return visitor.visitChildren(self)




    def defaultValue(self):

        localctx = db2_parser.DefaultValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_defaultValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CheckConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_checkCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckCondition" ):
                listener.enterCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckCondition" ):
                listener.exitCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheckCondition" ):
                return visitor.visitCheckCondition(self)
            else:
                return visitor.visitChildren(self)




    def checkCondition(self):

        localctx = db2_parser.CheckConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_checkCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateViewStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(db2_parser.CREATE, 0)

        def VIEW(self):
            return self.getToken(db2_parser.VIEW, 0)

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def AS(self):
            return self.getToken(db2_parser.AS, 0)

        def selectStatement(self):
            return self.getTypedRuleContext(db2_parser.SelectStatementContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnList(self):
            return self.getTypedRuleContext(db2_parser.ColumnListContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_createViewStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateViewStatement" ):
                listener.enterCreateViewStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateViewStatement" ):
                listener.exitCreateViewStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateViewStatement" ):
                return visitor.visitCreateViewStatement(self)
            else:
                return visitor.visitChildren(self)




    def createViewStatement(self):

        localctx = db2_parser.CreateViewStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_createViewStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.match(db2_parser.CREATE)
            self.state = 618
            self.match(db2_parser.VIEW)
            self.state = 619
            self.match(db2_parser.IDENTIFIER)
            self.state = 624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 620
                self.match(db2_parser.LPAREN)
                self.state = 621
                self.columnList()
                self.state = 622
                self.match(db2_parser.RPAREN)


            self.state = 626
            self.match(db2_parser.AS)
            self.state = 627
            self.selectStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateIndexStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(db2_parser.CREATE, 0)

        def INDEX(self):
            return self.getToken(db2_parser.INDEX, 0)

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def columnList(self):
            return self.getTypedRuleContext(db2_parser.ColumnListContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_createIndexStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateIndexStatement" ):
                listener.enterCreateIndexStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateIndexStatement" ):
                listener.exitCreateIndexStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateIndexStatement" ):
                return visitor.visitCreateIndexStatement(self)
            else:
                return visitor.visitChildren(self)




    def createIndexStatement(self):

        localctx = db2_parser.CreateIndexStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_createIndexStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 629
            self.match(db2_parser.CREATE)
            self.state = 630
            self.match(db2_parser.INDEX)
            self.state = 631
            self.match(db2_parser.IDENTIFIER)
            self.state = 632
            self.match(db2_parser.ON)
            self.state = 633
            self.tableName()
            self.state = 634
            self.match(db2_parser.LPAREN)
            self.state = 635
            self.columnList()
            self.state = 636
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateSequenceStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(db2_parser.CREATE, 0)

        def SEQUENCE(self):
            return self.getToken(db2_parser.SEQUENCE, 0)

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def START(self):
            return self.getToken(db2_parser.START, 0)

        def WITH(self):
            return self.getToken(db2_parser.WITH, 0)

        def startValue(self):
            return self.getTypedRuleContext(db2_parser.StartValueContext,0)


        def INCREMENT(self):
            return self.getToken(db2_parser.INCREMENT, 0)

        def BY(self):
            return self.getToken(db2_parser.BY, 0)

        def incrementValue(self):
            return self.getTypedRuleContext(db2_parser.IncrementValueContext,0)


        def MINVALUE(self):
            return self.getToken(db2_parser.MINVALUE, 0)

        def minValue(self):
            return self.getTypedRuleContext(db2_parser.MinValueContext,0)


        def MAXVALUE(self):
            return self.getToken(db2_parser.MAXVALUE, 0)

        def maxValue(self):
            return self.getTypedRuleContext(db2_parser.MaxValueContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_createSequenceStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateSequenceStatement" ):
                listener.enterCreateSequenceStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateSequenceStatement" ):
                listener.exitCreateSequenceStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateSequenceStatement" ):
                return visitor.visitCreateSequenceStatement(self)
            else:
                return visitor.visitChildren(self)




    def createSequenceStatement(self):

        localctx = db2_parser.CreateSequenceStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_createSequenceStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(db2_parser.CREATE)
            self.state = 639
            self.match(db2_parser.SEQUENCE)
            self.state = 640
            self.match(db2_parser.IDENTIFIER)
            self.state = 644
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==219:
                self.state = 641
                self.match(db2_parser.START)
                self.state = 642
                self.match(db2_parser.WITH)
                self.state = 643
                self.startValue()


            self.state = 649
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==220:
                self.state = 646
                self.match(db2_parser.INCREMENT)
                self.state = 647
                self.match(db2_parser.BY)
                self.state = 648
                self.incrementValue()


            self.state = 653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==221:
                self.state = 651
                self.match(db2_parser.MINVALUE)
                self.state = 652
                self.minValue()


            self.state = 657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==222:
                self.state = 655
                self.match(db2_parser.MAXVALUE)
                self.state = 656
                self.maxValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_startValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartValue" ):
                listener.enterStartValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartValue" ):
                listener.exitStartValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartValue" ):
                return visitor.visitStartValue(self)
            else:
                return visitor.visitChildren(self)




    def startValue(self):

        localctx = db2_parser.StartValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_startValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncrementValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_incrementValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncrementValue" ):
                listener.enterIncrementValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncrementValue" ):
                listener.exitIncrementValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncrementValue" ):
                return visitor.visitIncrementValue(self)
            else:
                return visitor.visitChildren(self)




    def incrementValue(self):

        localctx = db2_parser.IncrementValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_incrementValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_minValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValue" ):
                listener.enterMinValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValue" ):
                listener.exitMinValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValue" ):
                return visitor.visitMinValue(self)
            else:
                return visitor.visitChildren(self)




    def minValue(self):

        localctx = db2_parser.MinValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_minValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 663
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_maxValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValue" ):
                listener.enterMaxValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValue" ):
                listener.exitMaxValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValue" ):
                return visitor.visitMaxValue(self)
            else:
                return visitor.visitChildren(self)




    def maxValue(self):

        localctx = db2_parser.MaxValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_maxValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 665
            self.match(db2_parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER(self):
            return self.getToken(db2_parser.ALTER, 0)

        def TABLE(self):
            return self.getToken(db2_parser.TABLE, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def alterAction(self):
            return self.getTypedRuleContext(db2_parser.AlterActionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_alterStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterStatement" ):
                listener.enterAlterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterStatement" ):
                listener.exitAlterStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterStatement" ):
                return visitor.visitAlterStatement(self)
            else:
                return visitor.visitChildren(self)




    def alterStatement(self):

        localctx = db2_parser.AlterStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_alterStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 667
            self.match(db2_parser.ALTER)
            self.state = 668
            self.match(db2_parser.TABLE)
            self.state = 669
            self.tableName()
            self.state = 670
            self.alterAction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(db2_parser.ADD, 0)

        def COLUMN(self):
            return self.getToken(db2_parser.COLUMN, 0)

        def columnDefinition(self):
            return self.getTypedRuleContext(db2_parser.ColumnDefinitionContext,0)


        def DROP(self):
            return self.getToken(db2_parser.DROP, 0)

        def columnName(self):
            return self.getTypedRuleContext(db2_parser.ColumnNameContext,0)


        def MODIFY(self):
            return self.getToken(db2_parser.MODIFY, 0)

        def CONSTRAINT(self):
            return self.getToken(db2_parser.CONSTRAINT, 0)

        def constraintName(self):
            return self.getTypedRuleContext(db2_parser.ConstraintNameContext,0)


        def constraintDefinition(self):
            return self.getTypedRuleContext(db2_parser.ConstraintDefinitionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_alterAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterAction" ):
                listener.enterAlterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterAction" ):
                listener.exitAlterAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterAction" ):
                return visitor.visitAlterAction(self)
            else:
                return visitor.visitChildren(self)




    def alterAction(self):

        localctx = db2_parser.AlterActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_alterAction)
        try:
            self.state = 689
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 672
                self.match(db2_parser.ADD)
                self.state = 673
                self.match(db2_parser.COLUMN)
                self.state = 674
                self.columnDefinition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 675
                self.match(db2_parser.DROP)
                self.state = 676
                self.match(db2_parser.COLUMN)
                self.state = 677
                self.columnName()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 678
                self.match(db2_parser.MODIFY)
                self.state = 679
                self.match(db2_parser.COLUMN)
                self.state = 680
                self.columnDefinition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 681
                self.match(db2_parser.ADD)
                self.state = 682
                self.match(db2_parser.CONSTRAINT)
                self.state = 683
                self.constraintName()
                self.state = 684
                self.constraintDefinition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 686
                self.match(db2_parser.DROP)
                self.state = 687
                self.match(db2_parser.CONSTRAINT)
                self.state = 688
                self.constraintName()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_constraintName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintName" ):
                listener.enterConstraintName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintName" ):
                listener.exitConstraintName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintName" ):
                return visitor.visitConstraintName(self)
            else:
                return visitor.visitChildren(self)




    def constraintName(self):

        localctx = db2_parser.ConstraintNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_constraintName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIMARY(self):
            return self.getToken(db2_parser.PRIMARY, 0)

        def KEY(self):
            return self.getToken(db2_parser.KEY, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.LPAREN)
            else:
                return self.getToken(db2_parser.LPAREN, i)

        def columnList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ColumnListContext)
            else:
                return self.getTypedRuleContext(db2_parser.ColumnListContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.RPAREN)
            else:
                return self.getToken(db2_parser.RPAREN, i)

        def UNIQUE(self):
            return self.getToken(db2_parser.UNIQUE, 0)

        def FOREIGN(self):
            return self.getToken(db2_parser.FOREIGN, 0)

        def REFERENCES(self):
            return self.getToken(db2_parser.REFERENCES, 0)

        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def CHECK(self):
            return self.getToken(db2_parser.CHECK, 0)

        def checkCondition(self):
            return self.getTypedRuleContext(db2_parser.CheckConditionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_constraintDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintDefinition" ):
                listener.enterConstraintDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintDefinition" ):
                listener.exitConstraintDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintDefinition" ):
                return visitor.visitConstraintDefinition(self)
            else:
                return visitor.visitChildren(self)




    def constraintDefinition(self):

        localctx = db2_parser.ConstraintDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_constraintDefinition)
        self._la = 0 # Token type
        try:
            self.state = 722
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.enterOuterAlt(localctx, 1)
                self.state = 693
                self.match(db2_parser.PRIMARY)
                self.state = 694
                self.match(db2_parser.KEY)
                self.state = 695
                self.match(db2_parser.LPAREN)
                self.state = 696
                self.columnList()
                self.state = 697
                self.match(db2_parser.RPAREN)
                pass
            elif token in [114]:
                self.enterOuterAlt(localctx, 2)
                self.state = 699
                self.match(db2_parser.UNIQUE)
                self.state = 700
                self.match(db2_parser.LPAREN)
                self.state = 701
                self.columnList()
                self.state = 702
                self.match(db2_parser.RPAREN)
                pass
            elif token in [112]:
                self.enterOuterAlt(localctx, 3)
                self.state = 704
                self.match(db2_parser.FOREIGN)
                self.state = 705
                self.match(db2_parser.KEY)
                self.state = 706
                self.match(db2_parser.LPAREN)
                self.state = 707
                self.columnList()
                self.state = 708
                self.match(db2_parser.RPAREN)
                self.state = 709
                self.match(db2_parser.REFERENCES)
                self.state = 710
                self.tableName()
                self.state = 715
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 711
                    self.match(db2_parser.LPAREN)
                    self.state = 712
                    self.columnList()
                    self.state = 713
                    self.match(db2_parser.RPAREN)


                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 4)
                self.state = 717
                self.match(db2_parser.CHECK)
                self.state = 718
                self.match(db2_parser.LPAREN)
                self.state = 719
                self.checkCondition()
                self.state = 720
                self.match(db2_parser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(db2_parser.DROP, 0)

        def objectName(self):
            return self.getTypedRuleContext(db2_parser.ObjectNameContext,0)


        def TABLE(self):
            return self.getToken(db2_parser.TABLE, 0)

        def VIEW(self):
            return self.getToken(db2_parser.VIEW, 0)

        def INDEX(self):
            return self.getToken(db2_parser.INDEX, 0)

        def SEQUENCE(self):
            return self.getToken(db2_parser.SEQUENCE, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_dropStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropStatement" ):
                listener.enterDropStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropStatement" ):
                listener.exitDropStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropStatement" ):
                return visitor.visitDropStatement(self)
            else:
                return visitor.visitChildren(self)




    def dropStatement(self):

        localctx = db2_parser.DropStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_dropStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 724
            self.match(db2_parser.DROP)
            self.state = 725
            _la = self._input.LA(1)
            if not(((((_la - 85)) & ~0x3f) == 0 and ((1 << (_la - 85)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 726
            self.objectName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_objectName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectName" ):
                listener.enterObjectName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectName" ):
                listener.exitObjectName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectName" ):
                return visitor.visitObjectName(self)
            else:
                return visitor.visitChildren(self)




    def objectName(self):

        localctx = db2_parser.ObjectNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_objectName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrantStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRANT(self):
            return self.getToken(db2_parser.GRANT, 0)

        def privilegeList(self):
            return self.getTypedRuleContext(db2_parser.PrivilegeListContext,0)


        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def objectType(self):
            return self.getTypedRuleContext(db2_parser.ObjectTypeContext,0)


        def objectName(self):
            return self.getTypedRuleContext(db2_parser.ObjectNameContext,0)


        def TO(self):
            return self.getToken(db2_parser.TO, 0)

        def granteeList(self):
            return self.getTypedRuleContext(db2_parser.GranteeListContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_grantStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantStatement" ):
                listener.enterGrantStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantStatement" ):
                listener.exitGrantStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantStatement" ):
                return visitor.visitGrantStatement(self)
            else:
                return visitor.visitChildren(self)




    def grantStatement(self):

        localctx = db2_parser.GrantStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_grantStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self.match(db2_parser.GRANT)
            self.state = 731
            self.privilegeList()
            self.state = 732
            self.match(db2_parser.ON)
            self.state = 733
            self.objectType()
            self.state = 734
            self.objectName()
            self.state = 735
            self.match(db2_parser.TO)
            self.state = 736
            self.granteeList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrivilegeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def privilege(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.PrivilegeContext)
            else:
                return self.getTypedRuleContext(db2_parser.PrivilegeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_privilegeList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrivilegeList" ):
                listener.enterPrivilegeList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrivilegeList" ):
                listener.exitPrivilegeList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrivilegeList" ):
                return visitor.visitPrivilegeList(self)
            else:
                return visitor.visitChildren(self)




    def privilegeList(self):

        localctx = db2_parser.PrivilegeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_privilegeList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            self.privilege()
            self.state = 743
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 739
                self.match(db2_parser.COMMA)
                self.state = 740
                self.privilege()
                self.state = 745
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrivilegeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(db2_parser.SELECT, 0)

        def INSERT(self):
            return self.getToken(db2_parser.INSERT, 0)

        def UPDATE(self):
            return self.getToken(db2_parser.UPDATE, 0)

        def DELETE(self):
            return self.getToken(db2_parser.DELETE, 0)

        def ALL(self):
            return self.getToken(db2_parser.ALL, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_privilege

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrivilege" ):
                listener.enterPrivilege(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrivilege" ):
                listener.exitPrivilege(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrivilege" ):
                return visitor.visitPrivilege(self)
            else:
                return visitor.visitChildren(self)




    def privilege(self):

        localctx = db2_parser.PrivilegeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_privilege)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            _la = self._input.LA(1)
            if not(((((_la - 55)) & ~0x3f) == 0 and ((1 << (_la - 55)) & 458753) != 0) or _la==163):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE(self):
            return self.getToken(db2_parser.TABLE, 0)

        def VIEW(self):
            return self.getToken(db2_parser.VIEW, 0)

        def SEQUENCE(self):
            return self.getToken(db2_parser.SEQUENCE, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_objectType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectType" ):
                listener.enterObjectType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectType" ):
                listener.exitObjectType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectType" ):
                return visitor.visitObjectType(self)
            else:
                return visitor.visitChildren(self)




    def objectType(self):

        localctx = db2_parser.ObjectTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_objectType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 748
            _la = self._input.LA(1)
            if not(((((_la - 85)) & ~0x3f) == 0 and ((1 << (_la - 85)) & 11) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GranteeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grantee(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.GranteeContext)
            else:
                return self.getTypedRuleContext(db2_parser.GranteeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_granteeList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGranteeList" ):
                listener.enterGranteeList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGranteeList" ):
                listener.exitGranteeList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGranteeList" ):
                return visitor.visitGranteeList(self)
            else:
                return visitor.visitChildren(self)




    def granteeList(self):

        localctx = db2_parser.GranteeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_granteeList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self.grantee()
            self.state = 755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 751
                self.match(db2_parser.COMMA)
                self.state = 752
                self.grantee()
                self.state = 757
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GranteeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def PUBLIC(self):
            return self.getToken(db2_parser.PUBLIC, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_grantee

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrantee" ):
                listener.enterGrantee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrantee" ):
                listener.exitGrantee(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrantee" ):
                return visitor.visitGrantee(self)
            else:
                return visitor.visitChildren(self)




    def grantee(self):

        localctx = db2_parser.GranteeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_grantee)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            _la = self._input.LA(1)
            if not(_la==1 or _la==227):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RevokeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REVOKE(self):
            return self.getToken(db2_parser.REVOKE, 0)

        def privilegeList(self):
            return self.getTypedRuleContext(db2_parser.PrivilegeListContext,0)


        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def objectType(self):
            return self.getTypedRuleContext(db2_parser.ObjectTypeContext,0)


        def objectName(self):
            return self.getTypedRuleContext(db2_parser.ObjectNameContext,0)


        def FROM(self):
            return self.getToken(db2_parser.FROM, 0)

        def granteeList(self):
            return self.getTypedRuleContext(db2_parser.GranteeListContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_revokeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRevokeStatement" ):
                listener.enterRevokeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRevokeStatement" ):
                listener.exitRevokeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRevokeStatement" ):
                return visitor.visitRevokeStatement(self)
            else:
                return visitor.visitChildren(self)




    def revokeStatement(self):

        localctx = db2_parser.RevokeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_revokeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 760
            self.match(db2_parser.REVOKE)
            self.state = 761
            self.privilegeList()
            self.state = 762
            self.match(db2_parser.ON)
            self.state = 763
            self.objectType()
            self.state = 764
            self.objectName()
            self.state = 765
            self.match(db2_parser.FROM)
            self.state = 766
            self.granteeList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMIT(self):
            return self.getToken(db2_parser.COMMIT, 0)

        def WORK(self):
            return self.getToken(db2_parser.WORK, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_commitStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommitStatement" ):
                listener.enterCommitStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommitStatement" ):
                listener.exitCommitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommitStatement" ):
                return visitor.visitCommitStatement(self)
            else:
                return visitor.visitChildren(self)




    def commitStatement(self):

        localctx = db2_parser.CommitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_commitStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 768
            self.match(db2_parser.COMMIT)
            self.state = 770
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172:
                self.state = 769
                self.match(db2_parser.WORK)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RollbackStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROLLBACK(self):
            return self.getToken(db2_parser.ROLLBACK, 0)

        def WORK(self):
            return self.getToken(db2_parser.WORK, 0)

        def TO(self):
            return self.getToken(db2_parser.TO, 0)

        def SAVEPOINT(self):
            return self.getToken(db2_parser.SAVEPOINT, 0)

        def savepointName(self):
            return self.getTypedRuleContext(db2_parser.SavepointNameContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_rollbackStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRollbackStatement" ):
                listener.enterRollbackStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRollbackStatement" ):
                listener.exitRollbackStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRollbackStatement" ):
                return visitor.visitRollbackStatement(self)
            else:
                return visitor.visitChildren(self)




    def rollbackStatement(self):

        localctx = db2_parser.RollbackStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_rollbackStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 772
            self.match(db2_parser.ROLLBACK)
            self.state = 774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172:
                self.state = 773
                self.match(db2_parser.WORK)


            self.state = 779
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==226:
                self.state = 776
                self.match(db2_parser.TO)
                self.state = 777
                self.match(db2_parser.SAVEPOINT)
                self.state = 778
                self.savepointName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(db2_parser.BEGIN, 0)

        def WORK(self):
            return self.getToken(db2_parser.WORK, 0)

        def TRANSACTION(self):
            return self.getToken(db2_parser.TRANSACTION, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_beginStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginStatement" ):
                listener.enterBeginStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginStatement" ):
                listener.exitBeginStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginStatement" ):
                return visitor.visitBeginStatement(self)
            else:
                return visitor.visitChildren(self)




    def beginStatement(self):

        localctx = db2_parser.BeginStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_beginStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 781
            self.match(db2_parser.BEGIN)
            self.state = 783
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172 or _la==173:
                self.state = 782
                _la = self._input.LA(1)
                if not(_la==172 or _la==173):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SavepointNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_savepointName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSavepointName" ):
                listener.enterSavepointName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSavepointName" ):
                listener.exitSavepointName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSavepointName" ):
                return visitor.visitSavepointName(self)
            else:
                return visitor.visitChildren(self)




    def savepointName(self):

        localctx = db2_parser.SavepointNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_savepointName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(db2_parser.SET, 0)

        def optionName(self):
            return self.getTypedRuleContext(db2_parser.OptionNameContext,0)


        def EQUALS(self):
            return self.getToken(db2_parser.EQUALS, 0)

        def optionValue(self):
            return self.getTypedRuleContext(db2_parser.OptionValueContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_setStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetStatement" ):
                listener.enterSetStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetStatement" ):
                listener.exitSetStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetStatement" ):
                return visitor.visitSetStatement(self)
            else:
                return visitor.visitChildren(self)




    def setStatement(self):

        localctx = db2_parser.SetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_setStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 787
            self.match(db2_parser.SET)
            self.state = 788
            self.optionName()
            self.state = 789
            self.match(db2_parser.EQUALS)
            self.state = 790
            self.optionValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_optionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionName" ):
                listener.enterOptionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionName" ):
                listener.exitOptionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionName" ):
                return visitor.visitOptionName(self)
            else:
                return visitor.visitChildren(self)




    def optionName(self):

        localctx = db2_parser.OptionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_optionName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_optionValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionValue" ):
                listener.enterOptionValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionValue" ):
                listener.exitOptionValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionValue" ):
                return visitor.visitOptionValue(self)
            else:
                return visitor.visitChildren(self)




    def optionValue(self):

        localctx = db2_parser.OptionValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_optionValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(db2_parser.COMMENT, 0)

        def ON(self):
            return self.getToken(db2_parser.ON, 0)

        def objectName(self):
            return self.getTypedRuleContext(db2_parser.ObjectNameContext,0)


        def IS(self):
            return self.getToken(db2_parser.IS, 0)

        def STRING(self):
            return self.getToken(db2_parser.STRING, 0)

        def TABLE(self):
            return self.getToken(db2_parser.TABLE, 0)

        def COLUMN(self):
            return self.getToken(db2_parser.COLUMN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_commentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommentStatement" ):
                listener.enterCommentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommentStatement" ):
                listener.exitCommentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommentStatement" ):
                return visitor.visitCommentStatement(self)
            else:
                return visitor.visitChildren(self)




    def commentStatement(self):

        localctx = db2_parser.CommentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_commentStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.match(db2_parser.COMMENT)
            self.state = 797
            self.match(db2_parser.ON)
            self.state = 798
            _la = self._input.LA(1)
            if not(_la==85 or _la==224):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 799
            self.objectName()
            self.state = 800
            self.match(db2_parser.IS)
            self.state = 801
            self.match(db2_parser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(db2_parser.PrimaryExpressionContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def functionCall(self):
            return self.getTypedRuleContext(db2_parser.FunctionCallContext,0)


        def caseExpression(self):
            return self.getTypedRuleContext(db2_parser.CaseExpressionContext,0)


        def castExpression(self):
            return self.getTypedRuleContext(db2_parser.CastExpressionContext,0)


        def operator(self):
            return self.getTypedRuleContext(db2_parser.OperatorContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = db2_parser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 144
        self.enterRecursionRule(localctx, 144, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 804
                self.primaryExpression()
                pass

            elif la_ == 2:
                self.state = 805
                self.match(db2_parser.LPAREN)
                self.state = 806
                self.expression(0)
                self.state = 807
                self.match(db2_parser.RPAREN)
                pass

            elif la_ == 3:
                self.state = 809
                self.functionCall()
                pass

            elif la_ == 4:
                self.state = 810
                self.caseExpression()
                pass

            elif la_ == 5:
                self.state = 811
                self.castExpression()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 820
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,74,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = db2_parser.ExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 814
                    if not self.precpred(self._ctx, 5):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                    self.state = 815
                    self.operator()
                    self.state = 816
                    self.expression(6) 
                self.state = 822
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,74,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(db2_parser.LiteralContext,0)


        def columnReference(self):
            return self.getTypedRuleContext(db2_parser.ColumnReferenceContext,0)


        def parameter(self):
            return self.getTypedRuleContext(db2_parser.ParameterContext,0)


        def subquery(self):
            return self.getTypedRuleContext(db2_parser.SubqueryContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_primaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)




    def primaryExpression(self):

        localctx = db2_parser.PrimaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_primaryExpression)
        try:
            self.state = 827
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2, 3, 4, 5, 116, 177, 178, 179]:
                self.enterOuterAlt(localctx, 1)
                self.state = 823
                self.literal()
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 824
                self.columnReference()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 3)
                self.state = 825
                self.parameter()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 4)
                self.state = 826
                self.subquery()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(db2_parser.NUMBER, 0)

        def STRING(self):
            return self.getToken(db2_parser.STRING, 0)

        def DOUBLE_QUOTED_STRING(self):
            return self.getToken(db2_parser.DOUBLE_QUOTED_STRING, 0)

        def HEX_STRING(self):
            return self.getToken(db2_parser.HEX_STRING, 0)

        def NULL(self):
            return self.getToken(db2_parser.NULL, 0)

        def CURRENT_DATE(self):
            return self.getToken(db2_parser.CURRENT_DATE, 0)

        def CURRENT_TIME(self):
            return self.getToken(db2_parser.CURRENT_TIME, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(db2_parser.CURRENT_TIMESTAMP, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = db2_parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 829
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 60) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & -2305843009213693951) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self):
            return self.getTypedRuleContext(db2_parser.ColumnNameContext,0)


        def tableName(self):
            return self.getTypedRuleContext(db2_parser.TableNameContext,0)


        def DOT(self):
            return self.getToken(db2_parser.DOT, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_columnReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnReference" ):
                listener.enterColumnReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnReference" ):
                listener.exitColumnReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnReference" ):
                return visitor.visitColumnReference(self)
            else:
                return visitor.visitChildren(self)




    def columnReference(self):

        localctx = db2_parser.ColumnReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_columnReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 834
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                self.state = 831
                self.tableName()
                self.state = 832
                self.match(db2_parser.DOT)


            self.state = 836
            self.columnName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_tableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableName" ):
                listener.enterTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableName" ):
                listener.exitTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableName" ):
                return visitor.visitTableName(self)
            else:
                return visitor.visitChildren(self)




    def tableName(self):

        localctx = db2_parser.TableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_tableName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_columnName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnName" ):
                listener.enterColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnName" ):
                listener.exitColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnName" ):
                return visitor.visitColumnName(self)
            else:
                return visitor.visitChildren(self)




    def columnName(self):

        localctx = db2_parser.ColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_columnName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 840
            self.match(db2_parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUESTION(self):
            return self.getToken(db2_parser.QUESTION, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = db2_parser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            self.match(db2_parser.QUESTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arithmeticOperator(self):
            return self.getTypedRuleContext(db2_parser.ArithmeticOperatorContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(db2_parser.ComparisonOperatorContext,0)


        def logicalOperator(self):
            return self.getTypedRuleContext(db2_parser.LogicalOperatorContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = db2_parser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_operator)
        try:
            self.state = 847
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14, 15, 16, 17, 18, 51]:
                self.enterOuterAlt(localctx, 1)
                self.state = 844
                self.arithmeticOperator()
                pass
            elif token in [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 228]:
                self.enterOuterAlt(localctx, 2)
                self.state = 845
                self.comparisonOperator()
                pass
            elif token in [47, 48, 49, 50]:
                self.enterOuterAlt(localctx, 3)
                self.state = 846
                self.logicalOperator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(db2_parser.PLUS, 0)

        def MINUS(self):
            return self.getToken(db2_parser.MINUS, 0)

        def ASTERISK(self):
            return self.getToken(db2_parser.ASTERISK, 0)

        def SLASH(self):
            return self.getToken(db2_parser.SLASH, 0)

        def PERCENT(self):
            return self.getToken(db2_parser.PERCENT, 0)

        def POWER(self):
            return self.getToken(db2_parser.POWER, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_arithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticOperator" ):
                listener.enterArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticOperator" ):
                listener.exitArithmeticOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticOperator" ):
                return visitor.visitArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticOperator(self):

        localctx = db2_parser.ArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_arithmeticOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 849
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799814193152) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(db2_parser.EQ, 0)

        def NE(self):
            return self.getToken(db2_parser.NE, 0)

        def GT(self):
            return self.getToken(db2_parser.GT, 0)

        def LT(self):
            return self.getToken(db2_parser.LT, 0)

        def GE(self):
            return self.getToken(db2_parser.GE, 0)

        def LE(self):
            return self.getToken(db2_parser.LE, 0)

        def LIKE(self):
            return self.getToken(db2_parser.LIKE, 0)

        def NOT_LIKE(self):
            return self.getToken(db2_parser.NOT_LIKE, 0)

        def IN(self):
            return self.getToken(db2_parser.IN, 0)

        def NOT_IN(self):
            return self.getToken(db2_parser.NOT_IN, 0)

        def BETWEEN(self):
            return self.getToken(db2_parser.BETWEEN, 0)

        def NOT_BETWEEN(self):
            return self.getToken(db2_parser.NOT_BETWEEN, 0)

        def IS(self):
            return self.getToken(db2_parser.IS, 0)

        def IS_NOT(self):
            return self.getToken(db2_parser.IS_NOT, 0)

        def EXISTS(self):
            return self.getToken(db2_parser.EXISTS, 0)

        def NOT_EXISTS(self):
            return self.getToken(db2_parser.NOT_EXISTS, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = db2_parser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 140733193388032) != 0) or _la==228):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(db2_parser.AND, 0)

        def OR(self):
            return self.getToken(db2_parser.OR, 0)

        def NOT(self):
            return self.getToken(db2_parser.NOT, 0)

        def XOR(self):
            return self.getToken(db2_parser.XOR, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_logicalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperator" ):
                listener.enterLogicalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperator" ):
                listener.exitLogicalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalOperator" ):
                return visitor.visitLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def logicalOperator(self):

        localctx = db2_parser.LogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_logicalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2111062325329920) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionName(self):
            return self.getTypedRuleContext(db2_parser.FunctionNameContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def argumentList(self):
            return self.getTypedRuleContext(db2_parser.ArgumentListContext,0)


        def ASTERISK(self):
            return self.getToken(db2_parser.ASTERISK, 0)

        def DISTINCT(self):
            return self.getToken(db2_parser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(db2_parser.ALL, 0)

        def windowFunction(self):
            return self.getTypedRuleContext(db2_parser.WindowFunctionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = db2_parser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.state = 867
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 125, 126, 127, 128, 129, 130, 131, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149]:
                self.enterOuterAlt(localctx, 1)
                self.state = 855
                self.functionName()
                self.state = 856
                self.match(db2_parser.LPAREN)
                self.state = 858
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==163 or _la==164:
                    self.state = 857
                    _la = self._input.LA(1)
                    if not(_la==163 or _la==164):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 862
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 2, 3, 4, 5, 6, 24, 116, 125, 126, 127, 128, 129, 130, 131, 132, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 177, 178, 179, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216]:
                    self.state = 860
                    self.argumentList()
                    pass
                elif token in [16]:
                    self.state = 861
                    self.match(db2_parser.ASTERISK)
                    pass
                elif token in [7]:
                    pass
                else:
                    pass
                self.state = 864
                self.match(db2_parser.RPAREN)
                pass
            elif token in [204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216]:
                self.enterOuterAlt(localctx, 2)
                self.state = 866
                self.windowFunction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(db2_parser.IDENTIFIER, 0)

        def COUNT(self):
            return self.getToken(db2_parser.COUNT, 0)

        def SUM(self):
            return self.getToken(db2_parser.SUM, 0)

        def AVG(self):
            return self.getToken(db2_parser.AVG, 0)

        def MIN(self):
            return self.getToken(db2_parser.MIN, 0)

        def MAX(self):
            return self.getToken(db2_parser.MAX, 0)

        def COALESCE(self):
            return self.getToken(db2_parser.COALESCE, 0)

        def NULLIF(self):
            return self.getToken(db2_parser.NULLIF, 0)

        def SUBSTRING(self):
            return self.getToken(db2_parser.SUBSTRING, 0)

        def LENGTH(self):
            return self.getToken(db2_parser.LENGTH, 0)

        def UPPER(self):
            return self.getToken(db2_parser.UPPER, 0)

        def LOWER(self):
            return self.getToken(db2_parser.LOWER, 0)

        def TRIM(self):
            return self.getToken(db2_parser.TRIM, 0)

        def LTRIM(self):
            return self.getToken(db2_parser.LTRIM, 0)

        def RTRIM(self):
            return self.getToken(db2_parser.RTRIM, 0)

        def REPLACE(self):
            return self.getToken(db2_parser.REPLACE, 0)

        def TRANSLATE(self):
            return self.getToken(db2_parser.TRANSLATE, 0)

        def POSITION(self):
            return self.getToken(db2_parser.POSITION, 0)

        def LOCATE(self):
            return self.getToken(db2_parser.LOCATE, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_functionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionName" ):
                listener.enterFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionName" ):
                listener.exitFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionName" ):
                return visitor.visitFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def functionName(self):

        localctx = db2_parser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_functionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 869
            _la = self._input.LA(1)
            if not(_la==1 or ((((_la - 125)) & ~0x3f) == 0 and ((1 << (_la - 125)) & 33538175) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = db2_parser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 871
            self.expression(0)
            self.state = 876
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 872
                self.match(db2_parser.COMMA)
                self.state = 873
                self.expression(0)
                self.state = 878
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def windowFunctionName(self):
            return self.getTypedRuleContext(db2_parser.WindowFunctionNameContext,0)


        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def OVER(self):
            return self.getToken(db2_parser.OVER, 0)

        def windowSpecification(self):
            return self.getTypedRuleContext(db2_parser.WindowSpecificationContext,0)


        def argumentList(self):
            return self.getTypedRuleContext(db2_parser.ArgumentListContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_windowFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFunction" ):
                listener.enterWindowFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFunction" ):
                listener.exitWindowFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFunction" ):
                return visitor.visitWindowFunction(self)
            else:
                return visitor.visitChildren(self)




    def windowFunction(self):

        localctx = db2_parser.WindowFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_windowFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            self.windowFunctionName()
            self.state = 880
            self.match(db2_parser.LPAREN)
            self.state = 882
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 16777342) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & -2305842992039985663) != 0) or ((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & 8191) != 0):
                self.state = 881
                self.argumentList()


            self.state = 884
            self.match(db2_parser.RPAREN)
            self.state = 885
            self.match(db2_parser.OVER)
            self.state = 886
            self.windowSpecification()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROW_NUMBER(self):
            return self.getToken(db2_parser.ROW_NUMBER, 0)

        def RANK(self):
            return self.getToken(db2_parser.RANK, 0)

        def DENSE_RANK(self):
            return self.getToken(db2_parser.DENSE_RANK, 0)

        def NTILE(self):
            return self.getToken(db2_parser.NTILE, 0)

        def LAG(self):
            return self.getToken(db2_parser.LAG, 0)

        def LEAD(self):
            return self.getToken(db2_parser.LEAD, 0)

        def FIRST_VALUE(self):
            return self.getToken(db2_parser.FIRST_VALUE, 0)

        def LAST_VALUE(self):
            return self.getToken(db2_parser.LAST_VALUE, 0)

        def NTH_VALUE(self):
            return self.getToken(db2_parser.NTH_VALUE, 0)

        def PERCENT_RANK(self):
            return self.getToken(db2_parser.PERCENT_RANK, 0)

        def CUME_DIST(self):
            return self.getToken(db2_parser.CUME_DIST, 0)

        def PERCENTILE_CONT(self):
            return self.getToken(db2_parser.PERCENTILE_CONT, 0)

        def PERCENTILE_DISC(self):
            return self.getToken(db2_parser.PERCENTILE_DISC, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_windowFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFunctionName" ):
                listener.enterWindowFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFunctionName" ):
                listener.exitWindowFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFunctionName" ):
                return visitor.visitWindowFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def windowFunctionName(self):

        localctx = db2_parser.WindowFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_windowFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 888
            _la = self._input.LA(1)
            if not(((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & 8191) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def ROWS(self):
            return self.getToken(db2_parser.ROWS, 0)

        def RANGE(self):
            return self.getToken(db2_parser.RANGE, 0)

        def GROUPS(self):
            return self.getToken(db2_parser.GROUPS, 0)

        def PARTITION(self):
            return self.getToken(db2_parser.PARTITION, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.BY)
            else:
                return self.getToken(db2_parser.BY, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(db2_parser.ExpressionContext,i)


        def ORDER(self):
            return self.getToken(db2_parser.ORDER, 0)

        def orderByItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.OrderByItemContext)
            else:
                return self.getTypedRuleContext(db2_parser.OrderByItemContext,i)


        def frameSpecification(self):
            return self.getTypedRuleContext(db2_parser.FrameSpecificationContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(db2_parser.COMMA)
            else:
                return self.getToken(db2_parser.COMMA, i)

        def getRuleIndex(self):
            return db2_parser.RULE_windowSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowSpecification" ):
                listener.enterWindowSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowSpecification" ):
                listener.exitWindowSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowSpecification" ):
                return visitor.visitWindowSpecification(self)
            else:
                return visitor.visitChildren(self)




    def windowSpecification(self):

        localctx = db2_parser.WindowSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_windowSpecification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 890
            self.match(db2_parser.LPAREN)
            self.state = 901
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==92:
                self.state = 891
                self.match(db2_parser.PARTITION)
                self.state = 892
                self.match(db2_parser.BY)
                self.state = 893
                self.expression(0)
                self.state = 898
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==10:
                    self.state = 894
                    self.match(db2_parser.COMMA)
                    self.state = 895
                    self.expression(0)
                    self.state = 900
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 903
                self.match(db2_parser.ORDER)
                self.state = 904
                self.match(db2_parser.BY)
                self.state = 905
                self.orderByItem()
                self.state = 910
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==10:
                    self.state = 906
                    self.match(db2_parser.COMMA)
                    self.state = 907
                    self.orderByItem()
                    self.state = 912
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 915
            _la = self._input.LA(1)
            if not(_la==69 or _la==187 or _la==188):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 917
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2199040032894) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & -2305842992039985663) != 0) or ((((_la - 189)) & ~0x3f) == 0 and ((1 << (_la - 189)) & 268402697) != 0):
                self.state = 916
                self.frameSpecification()


            self.state = 919
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def frameStart(self):
            return self.getTypedRuleContext(db2_parser.FrameStartContext,0)


        def BETWEEN(self):
            return self.getToken(db2_parser.BETWEEN, 0)

        def AND(self):
            return self.getToken(db2_parser.AND, 0)

        def frameEnd(self):
            return self.getTypedRuleContext(db2_parser.FrameEndContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_frameSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrameSpecification" ):
                listener.enterFrameSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrameSpecification" ):
                listener.exitFrameSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrameSpecification" ):
                return visitor.visitFrameSpecification(self)
            else:
                return visitor.visitChildren(self)




    def frameSpecification(self):

        localctx = db2_parser.FrameSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_frameSpecification)
        try:
            self.state = 927
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 2, 3, 4, 5, 6, 24, 116, 125, 126, 127, 128, 129, 130, 131, 132, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 177, 178, 179, 189, 192, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216]:
                self.enterOuterAlt(localctx, 1)
                self.state = 921
                self.frameStart()
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 922
                self.match(db2_parser.BETWEEN)
                self.state = 923
                self.frameStart()
                self.state = 924
                self.match(db2_parser.AND)
                self.state = 925
                self.frameEnd()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameStartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNBOUNDED(self):
            return self.getToken(db2_parser.UNBOUNDED, 0)

        def PRECEDING(self):
            return self.getToken(db2_parser.PRECEDING, 0)

        def CURRENT(self):
            return self.getToken(db2_parser.CURRENT, 0)

        def ROW(self):
            return self.getToken(db2_parser.ROW, 0)

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def FOLLOWING(self):
            return self.getToken(db2_parser.FOLLOWING, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_frameStart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrameStart" ):
                listener.enterFrameStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrameStart" ):
                listener.exitFrameStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrameStart" ):
                return visitor.visitFrameStart(self)
            else:
                return visitor.visitChildren(self)




    def frameStart(self):

        localctx = db2_parser.FrameStartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_frameStart)
        try:
            self.state = 939
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 929
                self.match(db2_parser.UNBOUNDED)
                self.state = 930
                self.match(db2_parser.PRECEDING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 931
                self.match(db2_parser.CURRENT)
                self.state = 932
                self.match(db2_parser.ROW)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 933
                self.expression(0)
                self.state = 934
                self.match(db2_parser.PRECEDING)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 936
                self.expression(0)
                self.state = 937
                self.match(db2_parser.FOLLOWING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameEndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNBOUNDED(self):
            return self.getToken(db2_parser.UNBOUNDED, 0)

        def FOLLOWING(self):
            return self.getToken(db2_parser.FOLLOWING, 0)

        def CURRENT(self):
            return self.getToken(db2_parser.CURRENT, 0)

        def ROW(self):
            return self.getToken(db2_parser.ROW, 0)

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def PRECEDING(self):
            return self.getToken(db2_parser.PRECEDING, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_frameEnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrameEnd" ):
                listener.enterFrameEnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrameEnd" ):
                listener.exitFrameEnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrameEnd" ):
                return visitor.visitFrameEnd(self)
            else:
                return visitor.visitChildren(self)




    def frameEnd(self):

        localctx = db2_parser.FrameEndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_frameEnd)
        try:
            self.state = 951
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 941
                self.match(db2_parser.UNBOUNDED)
                self.state = 942
                self.match(db2_parser.FOLLOWING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 943
                self.match(db2_parser.CURRENT)
                self.state = 944
                self.match(db2_parser.ROW)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 945
                self.expression(0)
                self.state = 946
                self.match(db2_parser.PRECEDING)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 948
                self.expression(0)
                self.state = 949
                self.match(db2_parser.FOLLOWING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(db2_parser.CASE, 0)

        def END(self):
            return self.getToken(db2_parser.END, 0)

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(db2_parser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(db2_parser.WhenClauseContext,i)


        def ELSE(self):
            return self.getToken(db2_parser.ELSE, 0)

        def elseExpression(self):
            return self.getTypedRuleContext(db2_parser.ElseExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = db2_parser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.match(db2_parser.CASE)
            self.state = 955
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 16777342) != 0) or ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & -2305842992039985663) != 0) or ((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & 8191) != 0):
                self.state = 954
                self.expression(0)


            self.state = 958 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 957
                self.whenClause()
                self.state = 960 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==133):
                    break

            self.state = 964
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==135:
                self.state = 962
                self.match(db2_parser.ELSE)
                self.state = 963
                self.elseExpression()


            self.state = 966
            self.match(db2_parser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(db2_parser.WHEN, 0)

        def whenExpression(self):
            return self.getTypedRuleContext(db2_parser.WhenExpressionContext,0)


        def THEN(self):
            return self.getToken(db2_parser.THEN, 0)

        def thenExpression(self):
            return self.getTypedRuleContext(db2_parser.ThenExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_whenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenClause" ):
                listener.enterWhenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenClause" ):
                listener.exitWhenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenClause" ):
                return visitor.visitWhenClause(self)
            else:
                return visitor.visitChildren(self)




    def whenClause(self):

        localctx = db2_parser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self.match(db2_parser.WHEN)
            self.state = 969
            self.whenExpression()
            self.state = 970
            self.match(db2_parser.THEN)
            self.state = 971
            self.thenExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_whenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenExpression" ):
                listener.enterWhenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenExpression" ):
                listener.exitWhenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenExpression" ):
                return visitor.visitWhenExpression(self)
            else:
                return visitor.visitChildren(self)




    def whenExpression(self):

        localctx = db2_parser.WhenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_whenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 973
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_thenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenExpression" ):
                listener.enterThenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenExpression" ):
                listener.exitThenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenExpression" ):
                return visitor.visitThenExpression(self)
            else:
                return visitor.visitChildren(self)




    def thenExpression(self):

        localctx = db2_parser.ThenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_thenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def getRuleIndex(self):
            return db2_parser.RULE_elseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseExpression" ):
                listener.enterElseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseExpression" ):
                listener.exitElseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseExpression" ):
                return visitor.visitElseExpression(self)
            else:
                return visitor.visitChildren(self)




    def elseExpression(self):

        localctx = db2_parser.ElseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_elseExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAST(self):
            return self.getToken(db2_parser.CAST, 0)

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(db2_parser.ExpressionContext,0)


        def AS(self):
            return self.getToken(db2_parser.AS, 0)

        def dataType(self):
            return self.getTypedRuleContext(db2_parser.DataTypeContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_castExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastExpression" ):
                listener.enterCastExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastExpression" ):
                listener.exitCastExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastExpression" ):
                return visitor.visitCastExpression(self)
            else:
                return visitor.visitChildren(self)




    def castExpression(self):

        localctx = db2_parser.CastExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_castExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 979
            self.match(db2_parser.CAST)
            self.state = 980
            self.match(db2_parser.LPAREN)
            self.state = 981
            self.expression(0)
            self.state = 982
            self.match(db2_parser.AS)
            self.state = 983
            self.dataType()
            self.state = 984
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(db2_parser.LPAREN, 0)

        def selectStatement(self):
            return self.getTypedRuleContext(db2_parser.SelectStatementContext,0)


        def RPAREN(self):
            return self.getToken(db2_parser.RPAREN, 0)

        def getRuleIndex(self):
            return db2_parser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubquery" ):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)




    def subquery(self):

        localctx = db2_parser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 986
            self.match(db2_parser.LPAREN)
            self.state = 987
            self.selectStatement()
            self.state = 988
            self.match(db2_parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[7] = self.tableExpression_sempred
        self._predicates[72] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def tableExpression_sempred(self, localctx:TableExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 5)
         




